<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>11盛最多水的容器</title>
    <url>/2024/02/09/11%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p>
<p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49 </span><br><span class="line">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：height = [1,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>



<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>设两指针 <code>i</code> , <code>j</code> ，指向的高度分别为 <code>h[i]</code>, <code>h[j]</code> 。此题的难点在于如何移动双指针，不会丢失面积最大值。</p>
<p>在每个状态下，无论长板或短板向中间移动一格，都会导致水槽底边宽度变短：</p>
<ul>
<li>若向内移动短板，水槽的短板可能变大，因此下个水槽的面积可能增大 。</li>
<li>若向内移动长板，水槽的短板不变或变小，因此下个水槽的面积一定变小 。</li>
</ul>
<p>因此每次都是移动短板。</p>
<p>可以证明，在短板向内移动的过程中，一定不会丢失面积最大值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>, right=height.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> ans=(right-left) * <span class="built_in">min</span>(height[left], height[right]);</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[left]&lt;height[right])&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans, (right-left) * <span class="built_in">min</span>(height[left], height[right]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>334递增的三元子序列</title>
    <url>/2024/02/08/334%E9%80%92%E5%A2%9E%E7%9A%84%E4%B8%89%E5%85%83%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个整数数组 <code>nums</code> ，判断这个数组中是否存在长度为 <code>3</code> 的递增子序列。</p>
<p>如果存在这样的三元组下标 <code>(i, j, k)</code> 且满足 <code>i &lt; j &lt; k</code> ，使得 <code>nums[i] &lt; nums[j] &lt; nums[k]</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,4,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：任何 i &lt; j &lt; k 的三元组都满足题意</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,4,3,2,1]</span><br><span class="line">输出：false</span><br><span class="line">解释：不存在满足题意的三元组</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,1,5,0,4,6]</span><br><span class="line">输出：true</span><br><span class="line">解释：三元组 (3, 4, 5) 满足题意，因为 nums[3] == 0 &lt; nums[4] == 4 &lt; nums[5] == 6</span><br></pre></td></tr></table></figure>



<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="方法一：双向遍历"><a href="#方法一：双向遍历" class="headerlink" title="方法一：双向遍历"></a>方法一：双向遍历</h2><p>存在三元组下标 <code>(i, j, k)</code> 等价于<code>nums[j]</code>左边的最小值小于<code>nums[j]</code>，<code>nums[j]</code>右边的最大值大于<code>nums[j]</code>。</p>
<p>因此，可以维护数组中每个元素左边的最小值和右边的最大值。</p>
<p>创建两个长度为<code>n</code>的数组<code>leftmin</code>和<code>rightmax</code>，通过一次正向遍历计算<code>leftmin</code>，一次反向遍历计算<code>rightmax</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">increasingTriplet</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">3</span>)&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftmin</span><span class="params">(n,<span class="number">0</span>)</span>, <span class="title">rightmax</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        leftmin[<span class="number">0</span>]=nums[<span class="number">0</span>];     </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            leftmin[i]=<span class="built_in">min</span>(nums[i],leftmin[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        rightmax[n<span class="number">-1</span>]=nums[n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            rightmax[i]=<span class="built_in">max</span>(nums[i], rightmax[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(leftmin[i<span class="number">-1</span>]&lt;nums[i]&amp;&amp;nums[i]&lt;rightmax[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="方法二：贪心"><a href="#方法二：贪心" class="headerlink" title="方法二：贪心"></a>方法二：贪心</h2><p>贪心策略：在遍历数组的过程中，维护两个变量<code>first</code>和 <code>second</code>，使得<code>first&lt;second</code>恒成立，并使<code>first</code>和 <code>second</code>尽可能小。</p>
<p>在寻找第三个元素<code>num</code>时，如果</p>
<ol>
<li><code>num&gt;second</code>, 那么三元子序列找到了。</li>
<li><code>first&lt;num&lt;=second</code>，那么将<code>second</code>更新为<code>num</code>。在当前位置未找到<code>third</code>的情况下，将<code>second</code>变得更小将更有利于找到<code>third</code>。</li>
<li><code>num&lt;=first</code>，那么将<code>first</code>更新为<code>num</code>。虽然此时<code>first</code>在<code>second</code>的后面，但并不妨碍。在更新前，已经存在<code>first‘&lt;second</code>，此时能否成功找到<code>third</code>，只与<code>second</code>有关，和更新完的<code>first</code>并没有关系。</li>
</ol>
<p>**使用贪心可以将空间复杂度优化为：O(1)**。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">increasingTriplet</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> first = nums[<span class="number">0</span>], second = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;second)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]&gt;first &amp;&amp; nums[i]&lt;=second)&#123;</span><br><span class="line">                second=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                first=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>605种花问题</title>
    <url>/2024/02/08/605%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p>
<p>给你一个整数数组 <code>flowerbed</code> 表示花坛，由若干 <code>0</code> 和 <code>1</code> 组成，其中 <code>0</code> 表示没种植花，<code>1</code> 表示种植了花。另有一个数 <code>n</code> ，能否在不打破种植规则的情况下种入 <code>n</code> 朵花？能则返回 <code>true</code> ，不能则返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：flowerbed = [1,0,0,0,1], n = 1</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：flowerbed = [1,0,0,0,1], n = 2</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>



<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先使用贪心策略，在不打破规则的情况下种植尽可能多的花，然后判断可以种入的花的最大数量是否≥n。</p>
<p>可以种花的条件是<strong>数组中出现连续的三个0</strong>。</p>
<p>此题的边界情况需要额外注意，若可种植的位置<code>flowerbed[i]</code>在数组的开头或末尾，通过忽略<code>flowerbed[i-1]</code>或<code>flowerbed[i+1]</code>进行条件的判断是比较方便的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPlaceFlowers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; flowerbed, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len=flowerbed.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((i==<span class="number">0</span> || flowerbed[i<span class="number">-1</span>]==<span class="number">0</span>) &amp;&amp; flowerbed[i]==<span class="number">0</span> &amp;&amp;(i+<span class="number">1</span>==len || flowerbed[i+<span class="number">1</span>]==<span class="number">0</span>))&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                flowerbed[i]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans&gt;=n;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>790多米诺和托米诺平铺</title>
    <url>/2024/02/13/790%E5%A4%9A%E7%B1%B3%E8%AF%BA%E5%92%8C%E6%89%98%E7%B1%B3%E8%AF%BA%E5%B9%B3%E9%93%BA/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>有两种形状的瓷砖：一种是 <code>2 x 1</code> 的多米诺形，另一种是形如 “L” 的托米诺形。两种形状都可以旋转。</p>
<p>给定整数 n ，返回可以平铺 <code>2 x n</code> 的面板的方法的数量。<strong>返回对</strong> <code>10^9 + 7</code> <strong>取模</strong> 的值。</p>
<p>平铺指的是每个正方形都必须有瓷砖覆盖。两个平铺不同，当且仅当面板上有四个方向上的相邻单元中的两个，使得恰好有一个平铺有一个瓷砖占据两个正方形。</p>
<p><strong>示例 1:</strong></p>
<img src="https://raw.githubusercontent.com/lmqqqqqq/PicGo-Image/main/img/202402132147164.png" alt="image-20240213211831661" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: n = 3</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: n = 1</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>



<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>令在第 <em>i</em> 列前面的正方形都被瓷砖覆盖，在第 <em>i</em> 列后面的正方形都没有被瓷砖覆盖的状态为 dp[i]。</p>
<p>我最初的方法是建立dp[i] 与dp[i-1]，dp[i-2]， dp[i-3]的递推关系。但这样会产生重复的覆盖方案。是错误的。</p>
<p>正确的递推关系为：</p>
<p>第 <em>i</em> 列的正方形有四种被覆盖的情况：</p>
<ul>
<li><p>一个正方形都没有被覆盖，记为状态 0；</p>
</li>
<li><p>只有上方的正方形被覆盖，记为状态 1；</p>
</li>
<li><p>只有下方的正方形被覆盖，记为状态 2；</p>
</li>
<li><p>上下两个正方形都被覆盖，记为状态 3。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/lmqqqqqq/PicGo-Image/main/img/202402132200417.png" alt="image-20240213215452077"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTilings</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> dp[<span class="number">1005</span>][<span class="number">4</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">3</span>];</span><br><span class="line">            dp[i][<span class="number">1</span>]=(dp[i<span class="number">-1</span>][<span class="number">0</span>]+dp[i<span class="number">-1</span>][<span class="number">2</span>])%mod;</span><br><span class="line">            dp[i][<span class="number">2</span>]=(dp[i<span class="number">-1</span>][<span class="number">0</span>]+dp[i<span class="number">-1</span>][<span class="number">1</span>])%mod;</span><br><span class="line">            dp[i][<span class="number">3</span>]=(dp[i<span class="number">-1</span>][<span class="number">1</span>]+dp[i<span class="number">-1</span>][<span class="number">2</span>]+dp[i<span class="number">-1</span>][<span class="number">3</span>]+dp[i<span class="number">-1</span>][<span class="number">0</span>])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>1679K和数对的最大数目</title>
    <url>/2024/02/10/1679K%E5%92%8C%E6%95%B0%E5%AF%B9%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p>
<p>每一步操作中，你需要从数组中选出和为 <code>k</code> 的两个整数，并将它们移出数组。</p>
<p>返回你可以对数组执行的最大操作数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,4], k = 5</span><br><span class="line">输出：2</span><br><span class="line">解释：开始时 nums = [1,2,3,4]：</span><br><span class="line">- 移出 1 和 4 ，之后 nums = [2,3]</span><br><span class="line">- 移出 2 和 3 ，之后 nums = []</span><br><span class="line">不再有和为 5 的数对，因此最多执行 2 次操作。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,1,3,4,3], k = 6</span><br><span class="line">输出：1</span><br><span class="line">解释：开始时 nums = [3,1,3,4,3]：</span><br><span class="line">- 移出前两个 3 ，之后nums = [1,4,3]</span><br><span class="line">不再有和为 6 的数对，因此最多执行 1 次操作。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^9</code></li>
<li><code>1 &lt;= k &lt;= 10^9</code></li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h2><ol>
<li><p>先将数据排序，用两个指针分别指向数组的头尾。</p>
</li>
<li><p>再将两个指针指向的数求和。</p>
<ul>
<li>若和大于<code>k</code>，右指针左移，使和变小。</li>
<li>若和小于<code>k</code>，左指针右移，使和变大。</li>
<li>若和等于<code>k</code>，则两个指针都往中间移动，<code>ans</code>+1。</li>
</ul>
</li>
<li><p>循环步骤2直至左指针大于右指针。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>, right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left]+nums[right]==k)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[left]+nums[right]&lt;k)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="方法二：哈希表"><a href="#方法二：哈希表" class="headerlink" title="方法二：哈希表"></a>方法二：哈希表</h2><p>使用哈希表统计每个整数出现的次数，(x,k−x) 这两个数最多可以被移出 <em>min</em>⁡( count(x), count(k-x) )次。</p>
<p><strong>当2x&#x3D;k时，需要特殊判断</strong>。</p>
<p>需要注意的是：</p>
<ul>
<li>访问一个未在<code>unordered_map</code>或 <code>map</code> 中存在的键，那么会自动创建该键，并将value初始化为默认值。</li>
<li>在<code>map</code>中，插入、删除和查找操作的时间复杂度是 <em>O</em>(log<em>n</em>)，在<code>unordered_map</code>中，是 <em>O</em>(1)。</li>
<li><code>count()</code> 和 <code>find()</code> 成员函数都是用于检查某个键是否存在的方法，<code>count()</code> 返回的是键的出现次数（0 或 1），<code>find()</code> 返回的是指向键值对的迭代器。</li>
<li>此题k的数量级为10^9, 因此不能遍历1-k的所有整数，而应该遍历哈希表中的所有键值对。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums) &#123;</span><br><span class="line">            m[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [key,value]:m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(key*<span class="number">2</span>==k)&#123;</span><br><span class="line">                ans+=value/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(key*<span class="number">2</span>&lt;k &amp;&amp; m.<span class="built_in">count</span>(k-key))&#123;</span><br><span class="line">                ans+=<span class="built_in">min</span>(value,m[k-key]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>emplace_back Vs push_back</title>
    <url>/2023/09/23/emplace-back/</url>
    <content><![CDATA[<p><code>emplace_back()</code>是C++11的新特性</p>
<h2 id="emplace-back-和push-back-的区别"><a href="#emplace-back-和push-back-的区别" class="headerlink" title="emplace_back()和push_back()的区别"></a>emplace_back()和push_back()的区别</h2><ol>
<li><code>push_back()</code> 在vector尾部添加一个元素时，首先会创建一个临时对象，然后再将这个临时对象移动或拷贝到 vector 中<ul>
<li>如果是拷贝的话，事后会自动销毁先前创建的这个临时元素</li>
</ul>
</li>
<li><code>emplace_back()</code> 是直接在 vector 尾部创建这个元素，省去了移动或者拷贝元素的过程</li>
<li>但 <code>emplace_back()</code>并不是任何场景效率都比 <code>push_back()</code>高</li>
</ol>
<h2 id="emplace-back-效率更高的应用场景"><a href="#emplace-back-效率更高的应用场景" class="headerlink" title="emplace_back()效率更高的应用场景"></a>emplace_back()效率更高的应用场景</h2><p>在向 vector 中添加元素时（假设元素类型是一个类类型）</p>
<ol>
<li>如果添加的是类类型的有参构造函数的参数类型对应的变量：<ul>
<li>如果通过 <code>push_back()</code> 方式添加，则会调用<strong>一次有参构造 + 一次移动构造</strong> ，如果移动构造不可用则为拷贝构造</li>
<li>如果通过 <code>emplace_back()</code> 方式添加，则只会调用<strong>一次有参构造</strong></li>
</ul>
</li>
<li>如果添加的是类类型的变量：<ul>
<li>不论是通过 <code>push_back()</code> 方式还是 <code>emplace_back()</code> 方式，都只会调用<strong>一次拷贝构造</strong></li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span> (<span class="type">int</span> num) &#123;</span><br><span class="line">        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span> (<span class="type">const</span> Person &amp; p) &#123;</span><br><span class="line">        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;num = p.num;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;num=&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;num &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span> (Person &amp;&amp; p) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;num = p.num;</span><br><span class="line">        p.num = <span class="number">0</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;num=&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;num &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Person</span> () &#123;</span><br><span class="line">        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; __LINE__ &lt;&lt; endl;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">10</span>);  <span class="comment">// 会调用一次有参构造+一次移动构造</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; __LINE__ &lt;&lt; endl;</span><br><span class="line">    v.<span class="built_in">emplace_back</span>(<span class="number">20</span>);  <span class="comment">// 会调用一次有参构造</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; __LINE__ &lt;&lt; endl;</span><br><span class="line">    v.<span class="built_in">push_back</span>(p1);  <span class="comment">// 会调用一次拷贝构造</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; __LINE__ &lt;&lt; endl;</span><br><span class="line">    v.<span class="built_in">emplace_back</span>(p1);  <span class="comment">// 会调用一次拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以有参构造中的参数类型的变量作为实参来使用 <code>push_back()</code>和<code>emplace_back()</code> ，可以提升效率，但我认为这种实参形式不易于理解</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="http://c.biancheng.net/view/6826.html">http://c.biancheng.net/view/6826.html</a></p>
<p><a href="https://blog.csdn.net/unonoi/article/details/114680819?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5-114680819-blog-119282296.235%5Ev38%5Epc_relevant_anti_t3_base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5-114680819-blog-119282296.235%5Ev38%5Epc_relevant_anti_t3_base&utm_relevant_index=9">https://blog.csdn.net/unonoi/article/details/114680819?spm=1001.2101.3001.6650.5&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-114680819-blog-119282296.235%5Ev38%5Epc_relevant_anti_t3_base&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-114680819-blog-119282296.235%5Ev38%5Epc_relevant_anti_t3_base&amp;utm_relevant_index=9</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>std::move</title>
    <url>/2023/09/15/std-move/</url>
    <content><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p><strong>左值</strong>：表达式结束后依然存在的持久对象(在<strong>内存</strong>中占有确定位置)</p>
<p><strong>右值</strong>：表达式结束时不再存在的临时对象(不在<strong>内存</strong>中占有确定位置）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> val; <span class="comment">// 对变量val进行了定义，故在栈上会给val分配内存地址</span></span><br><span class="line">val = <span class="number">4</span>; <span class="comment">// “=”要求左边是可修改的左值，4是临时参与运算的值，一般在寄存器上暂存</span></span><br></pre></td></tr></table></figure>



<h2 id="std-move函数"><a href="#std-move函数" class="headerlink" title="std::move函数"></a>std::move函数</h2><ul>
<li>将一个左值转换成右值引用，从而可以调用右值引用的拷贝构造函数</li>
<li>针对有在堆上为对象分配内存的情况</li>
<li>该函数仅仅做了**类型转换(可理解为static_cast转换),**对性能无影响。</li>
<li><strong>真正的移动操作</strong>在移动构造函数或者移动赋值操作符中发生，我们可以在自己的类中实现移动语义，避免深拷贝</li>
<li><strong>被move的值有没有失效，关键看有没有调用移动构造函数，或者移动复制运算符</strong><ul>
<li>单纯的<code>Foo &amp;&amp; f = std::move (x)</code>;  是不会调用移动构造或者移动赋值运算符的。 只是把右值给绑定到了<code>f</code>上。</li>
<li><code>Foo t = std::move (x)</code>, 这样才会调用移动构造函数</li>
</ul>
</li>
</ul>
<h2 id="Why-std-move"><a href="#Why-std-move" class="headerlink" title="Why std::move"></a>Why std::move</h2><p>右值引用和<code>std::move</code>广泛应用于在STL和自定义类中<strong>实现移动语义，避免拷贝，从而提升程序性能</strong></p>
<p>在没有右值引用之前，一个简单的数组类通常实现如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">int</span> size) : <span class="built_in">size_</span>(size) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">int</span>[size_];</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 深拷贝构造</span></span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">const</span> Array&amp; temp_array) &#123;</span><br><span class="line">        size_ = temp_array.size_;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="type">int</span>[size_];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size_; i ++) &#123;</span><br><span class="line">            data_[i] = temp_array.data_[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 深拷贝赋值,不可避免</span></span><br><span class="line">    Array&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Array&amp; temp_array) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line"> </span><br><span class="line">        size_ = temp_array.size_;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="type">int</span>[size_];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size_; i ++) &#123;</span><br><span class="line">            data_[i] = temp_array.data_[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~<span class="built_in">Array</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> *data_;</span><br><span class="line">    <span class="type">int</span> size_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>改进：提供一个<code>移动构造函数</code>，把被拷贝者的数据移动过来，之后丢弃被拷贝者，从而避免深拷贝</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">int</span> size) : <span class="built_in">size_</span>(size) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">int</span>[size_];</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 深拷贝构造</span></span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">const</span> Array&amp; temp_array) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 深拷贝赋值</span></span><br><span class="line">    Array&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Array&amp; temp_array) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 移动构造函数，可以浅拷贝</span></span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">const</span> Array&amp; temp_array, <span class="type">bool</span> move) &#123;</span><br><span class="line">        data_ = temp_array.data_;</span><br><span class="line">        size_ = temp_array.size_;</span><br><span class="line">        <span class="comment">// 为防止temp_array析构时delete data，提前置空其data_      </span></span><br><span class="line">        temp_array.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    ~<span class="built_in">Array</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] data_;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> *data_;</span><br><span class="line">    <span class="type">int</span> size_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样做有三个问题：</p>
<ol>
<li>不优雅，表示移动语义需要一个额外的参数</li>
<li><code>temp_array</code>是const左值引用，无法被修改为<code>nullptr</code></li>
<li>即使把函数参数改成非const <code>Array&amp; temp_array</code>，由于左值引用不能接右值，无法使用<code>Array a = Array(Array(), true);</code></li>
</ol>
<p>最终，使用右值引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Array a;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 左值a，用std::move转化为右值</span></span><br><span class="line">    <span class="function">Array <span class="title">b</span><span class="params">(std::move(a))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="std-move在STL容器中的应用"><a href="#std-move在STL容器中的应用" class="headerlink" title="std::move在STL容器中的应用"></a>std::move在STL容器中的应用</h2><p>在STL的很多容器中，都实现了以<strong>右值引用为参数</strong>的<strong>移动构造函数</strong>和<strong>移动赋值重载函数</strong>，或者其他函数</p>
<p>最常见的如std::vector的<code>push_back</code>和<code>emplace_back</code>。参数为左值引用意味着拷贝，为右值引用意味着移动。</p>
<p>有些STL类只有移动构造函数，比如<code>unique_ptr</code>，因此只能移动(转移内部对象所有权，或者叫浅拷贝)，不能深拷贝</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.cnblogs.com/shadow-lr/p/Introduce_Std-move.html">https://www.cnblogs.com/shadow-lr/p/Introduce_Std-move.html</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2024/02/26/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>并查集主要用来解决<strong>元素分组</strong>的问题。它支持两种操作：</p>
<ul>
<li><strong>合并（Union）</strong>：把两个不相交的集合合并成一个集合。</li>
<li><strong>查询（Find）</strong>：查询两个元素是否在同一个集合中。</li>
</ul>
<p>并查集的核心思想是<strong>用集合中的一个元素代表整个集合</strong>。</p>
<img src="https://raw.githubusercontent.com/lmqqqqqq/PicGo-Image/main/img/202402270258364.png" alt="image-20240227011735365" style="zoom: 50%;" />

<p>并查集是一个<strong>树状</strong>的结构，要寻找集合中的代表元素，只需要向上一层一层访问父节点。</p>
<p>通过以上知识，可以先写出最简单版本的并查集代码。</p>
<p><strong>初始化</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fa[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span> <span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        fa[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用数组fa来存储每个元素的父节点。</p>
<p><strong>查询</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==x)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用递归一层一层访问父节点，直到根节点。<strong>通过判断两个元素的根节点是否一致，得出他们是否属于同一集合。</strong></p>
<p><strong>合并</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fa[<span class="built_in">find</span>(i)]=<span class="built_in">find</span>(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h2><p>最简单的并查集效率是比较低的。merge（2，4）会使得树变成一条长链。随着链的增长，从底部找到跟节点将越来越慢。</p>
<img src="https://raw.githubusercontent.com/lmqqqqqq/PicGo-Image/main/img/202402270258866.png" alt="image-20240227015949913" style="zoom:50%;" />

<p>最好能够使得每个元素到根节点的距离尽可能短，距离只有1。</p>
<img src="https://raw.githubusercontent.com/lmqqqqqq/PicGo-Image/main/img/202402270258319.png" alt="image-20240227020533562" style="zoom:50%;" />

<p>为了实现路径压缩，<strong>只需要在查询的过程中，把沿途的每个节点的父节点都设为根节点</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路径压缩</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==x)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        fa[x]=<span class="built_in">find</span>(fa[x]); <span class="comment">// 父节点设为根节点</span></span><br><span class="line">        <span class="keyword">return</span> fa[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="按秩合并"><a href="#按秩合并" class="headerlink" title="按秩合并"></a>按秩合并</h2><p>虽然经过了路径压缩这一优化，但并查集的结构仍然可能比较复杂。因为路径压缩只在查询时进行，而且只压缩一条路径。对于以下这种情况：</p>
<img src="https://raw.githubusercontent.com/lmqqqqqq/PicGo-Image/main/img/202402270259336.png" alt="image-20240227023419143" style="zoom:67%;" />

<p>merge（7，8）有两种选择：把7的父节点设为8，或把8的父节点设为7。</p>
<p>显然后者好。要是把7的父节点设为8，会使树的深度增加1，每个节点寻找根节点的路径都会变长。虽然有路径压缩这一优化方案，但优化方案本身也是耗时的。如果把8的父节点设为7，就不会影响到原来的树结构。</p>
<p>所以，<strong>应该把简单的树往复杂的树上合并</strong>。</p>
<p>用一个数组depth记录每个根节点对应的树的深度。合并时比较两个根节点的depth，把depth小的往depth大的合并。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="built_in">find</span>(i), y=<span class="built_in">find</span>(j);</span><br><span class="line">    <span class="keyword">if</span>(depth[x]&lt;=depth[y])&#123;</span><br><span class="line">        fa[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        fa[y]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(depth[x]==depth[y] &amp;&amp; x!=y)&#123;</span><br><span class="line">        depth[y]++;  <span class="comment">//如果两个根节点深度相同，合并后的根节点深度+1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/93647900">https://zhuanlan.zhihu.com/p/93647900</a></p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>data structures</tag>
      </tags>
  </entry>
  <entry>
    <title>215数组中的第K个最大元素</title>
    <url>/2024/02/27/215%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。</p>
<p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p>
<p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4], k = 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [3,2,3,1,2,4,5,5,6], k = 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>一道非常经典的题目。</p>
<h2 id="方法一：快速排序"><a href="#方法一：快速排序" class="headerlink" title="方法一：快速排序"></a>方法一：快速排序</h2><p>每一次快速排序之后，可以确定一个元素的最终位置<code>q</code>，保证 <code>[1，q-1]</code> 中的每个元素都小于<code>a[q]</code>，<code>[q+1，r]</code> 中的每个元素都大于<code>a[q]</code>。虽然区间内元素是乱序的，但没有关系。如果某次划分的元素的下标正好是<code>q</code>，那么就得到了答案。</p>
<p>这道题和快速排序的区别是：此题只需要判断确定位置的元素下表与k的关系，并递归排序左&#x2F;右区间，不必同时排序两个区间。</p>
<p>其中需要注意的是数组中有相同元素的情况，不要死循环了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">quickselect</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r)</span><br><span class="line">            <span class="keyword">return</span> nums[k];</span><br><span class="line">        <span class="type">int</span> partition = nums[l], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">do</span> i++; <span class="keyword">while</span> (nums[i] &lt; partition);</span><br><span class="line">            <span class="keyword">do</span> j--; <span class="keyword">while</span> (nums[j] &gt; partition);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= j)<span class="keyword">return</span> <span class="built_in">quickselect</span>(nums, l, j, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">quickselect</span>(nums, j + <span class="number">1</span>, r, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickselect</span>(nums, <span class="number">0</span>, n - <span class="number">1</span>, n - k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="方法二：堆排序"><a href="#方法二：堆排序" class="headerlink" title="方法二：堆排序"></a>方法二：堆排序</h2><p>建立一个大根堆（aka <code>priority_queue</code>）,做 k-1 次删除操作之后，堆顶的元素就是答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">maxheap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> i, <span class="type">int</span> heapsize)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> left=i*<span class="number">2</span>+<span class="number">1</span>, right=i*<span class="number">2</span>+<span class="number">2</span>, largest=i;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;heapsize &amp;&amp; nums[left]&gt;nums[largest])&#123;</span><br><span class="line">            largest=left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right&lt;heapsize &amp;&amp; nums[right]&gt;nums[largest])&#123;</span><br><span class="line">            largest=right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(largest!=i)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i],nums[largest]);</span><br><span class="line">            <span class="built_in">maxheap</span>(nums,largest,heapsize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildheap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> heapsize)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=heapsize/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="built_in">maxheap</span>(nums,i,heapsize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> heapsize=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">buildheap</span>(nums,heapsize);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=nums.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;nums.<span class="built_in">size</span>()-k;i--)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[<span class="number">0</span>],nums[i]);</span><br><span class="line">            heapsize--;</span><br><span class="line">            <span class="built_in">maxheap</span>(nums,<span class="number">0</span>,heapsize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Modern C++ Item 1</title>
    <url>/2024/02/28/Effective%20Modern%20C++%20Item%201/</url>
    <content><![CDATA[<h1 id="Understand-template-type-deduction"><a href="#Understand-template-type-deduction" class="headerlink" title="Understand template type deduction"></a>Understand template type deduction</h1><p><code>auto</code>是建立在模板类型推导的基础上的，这项条款能帮助理解<code>auto</code>基于的模板类型推导。</p>
<p>我们将基于这个模板进行讨论:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(expr);		<span class="comment">// call f with some expression</span></span><br></pre></td></tr></table></figure>

<p>在编译期间，编译器使用<code>expr</code>进行两个类型推导：一个是针对<code>T</code>的，另一个是针对<code>ParamType</code>的。这两个类型通常是不同的，因为<code>ParamType</code>包含一些修饰，比如<code>const</code>和引用修饰符。在这种情况下，<code>ParamType</code>是<code>const T&amp;</code>。</p>
<p><code>T</code>的类型推导不仅取决于<code>expr</code>的类型，也取决于<code>ParamType</code>的类型。这里有三种情况：</p>
<h3 id="第一种情况-ParamType是引用或者指针-但不是通用引用"><a href="#第一种情况-ParamType是引用或者指针-但不是通用引用" class="headerlink" title="第一种情况: ParamType是引用或者指针, 但不是通用引用"></a>第一种情况: <em>ParamType</em>是引用或者指针, 但不是通用引用</h3><p>规则是:</p>
<ul>
<li>如果 <em><strong>expr</strong></em> 的类型是引用, 则忽略引用部分.</li>
<li>然后将 <em><strong>expr</strong></em> 的类型与 <em><strong>ParamType</strong></em> 进行模式匹配以确定 <em><strong>T</strong></em>.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = x;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);                           <span class="comment">//T是int，param的类型是int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);                          <span class="comment">//T是const int，param的类型是const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx);                          <span class="comment">//T是const int，param的类型是const int&amp;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果我们将<code>f</code>的形参类型<code>T&amp;</code>改为<code>const T&amp;</code>，情况有所变化，<code>cx</code>和<code>rx</code>的<code>const</code>ness依然被遵守，但是因为假设<code>param</code>是reference-to-<code>const</code>，<code>const</code>不再被推导为<code>T</code>的一部分：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp; param)</span></span>;         <span class="comment">//param现在是reference-to-const</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;                     <span class="comment">//如之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;               <span class="comment">//如之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = x;              <span class="comment">//如之前一样</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);                           <span class="comment">//T是int，param的类型是const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);                          <span class="comment">//T是int，param的类型是const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx);                          <span class="comment">//T是int，param的类型是const int&amp;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果<code>param</code>是一个指针（或者指向<code>const</code>的指针）而不是引用，情况本质上也一样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T* param)</span></span>;               <span class="comment">//param现在是指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;                     <span class="comment">//同之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *px = &amp;x;             <span class="comment">//px是指向作为const int的x的指针</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(&amp;x);                          <span class="comment">//T是int，param的类型是int*</span></span><br><span class="line"><span class="built_in">f</span>(px);                          <span class="comment">//T是const int，param的类型是const int*</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="第二种情况-ParamType是通用引用"><a href="#第二种情况-ParamType是通用引用" class="headerlink" title="第二种情况: ParamType是通用引用"></a>第二种情况: <em><strong>ParamType</strong></em>是通用引用</h3><p>规则是:</p>
<ul>
<li>如果 <em><strong>expr</strong></em> 是左值，则 <strong>T</strong> 和 <strong>ParamType</strong> 都被推导为左值引用.</li>
<li>如果 <em><strong>expr</strong></em> 是右值，则适用第一种情况规则.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;              <span class="comment">//param现在是一个通用引用类型</span></span><br><span class="line">        </span><br><span class="line"><span class="type">int</span> x=<span class="number">27</span>;                       <span class="comment">//如之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx=x;                 <span class="comment">//如之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp; rx=cx;              <span class="comment">//如之前一样</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);                           <span class="comment">//x是左值，所以T是int&amp;，</span></span><br><span class="line">                                <span class="comment">//param类型也是int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(cx);                          <span class="comment">//cx是左值，所以T是const int&amp;，</span></span><br><span class="line">                                <span class="comment">//param类型也是const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(rx);                          <span class="comment">//rx是左值，所以T是const int&amp;，</span></span><br><span class="line">                                <span class="comment">//param类型也是const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">27</span>);                          <span class="comment">//27是右值，所以T是int，</span></span><br><span class="line">                                <span class="comment">//param类型就是int&amp;&amp;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>当通用引用被使用时，类型推导会区分左值实参和右值实参。</strong></p>
<h3 id="第三种情况-ParamType既不是指针也不是引用"><a href="#第三种情况-ParamType既不是指针也不是引用" class="headerlink" title="第三种情况: ParamType既不是指针也不是引用"></a>第三种情况: <em><strong>ParamType</strong></em>既不是指针也不是引用</h3><p>在这种情况下, 参数以<strong>传值（pass-by-value）</strong>的方式处理。无论传递什么，<code>param</code>都会成为它的一份拷贝——一个完整的新对象。</p>
<p>规则是：</p>
<ul>
<li>如果 *<strong>expr*</strong> 的类型是引用, 则忽略引用部分。</li>
<li>在忽略 <em><strong>expr</strong></em> 的引用性之后, 也忽略任何 <strong>const</strong> 和 <strong>volatile</strong>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;		<span class="comment">// param is now pass-by-value(按值传递)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = x;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> ptr =  <span class="string">&quot;Fun with pointers&quot;</span>;       <span class="comment">//ptr是一个常量指针，指向常量对象 </span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">f</span>(x);                           <span class="comment">//T和param的类型都是int</span></span><br><span class="line"><span class="built_in">f</span>(cx);                          <span class="comment">//T和param的类型都是int</span></span><br><span class="line"><span class="built_in">f</span>(rx);                          <span class="comment">//T和param的类型都是int</span></span><br><span class="line"><span class="built_in">f</span>(ptr);                         <span class="comment">//传递const char * const类型的实参</span></span><br></pre></td></tr></table></figure>

<p>即使<code>cx</code>和<code>rx</code>表示<code>const</code>值，<code>param</code>也不是<code>const</code>。<code>param</code>是一个完全独立于<code>cx</code>和<code>rx</code>的对象。</p>
<h3 id="数组和函数参数的衰减"><a href="#数组和函数参数的衰减" class="headerlink" title="数组和函数参数的衰减"></a>数组和函数参数的衰减</h3><p>当我们将数组名称作为参数传递给函数时，它实际上会衰减为<strong>指向数组中第一个元素的指针。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;			<span class="comment">// pass-by-value</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> name[] = <span class="string">&quot;J. P. Briggs&quot;</span>;	<span class="comment">//name的类型是const char[13]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(name); 				<span class="comment">//name是一个数组，但是T被推导为const char*</span></span><br></pre></td></tr></table></figure>

<p>但是如果添加对数组的引用, 就可以推断出数组类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(name);				<span class="comment">//传数组给f</span></span><br></pre></td></tr></table></figure>

<p>不只是数组会退化为指针，函数类型也会退化为一个函数指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunc</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>)</span></span>;         <span class="comment">//someFunc是一个函数，</span></span><br><span class="line">                                    <span class="comment">//类型是void(int, double)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(T param)</span></span>;                   <span class="comment">//传值给f1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(T &amp; param)</span></span>;                 <span class="comment">//传引用给f2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f1</span>(someFunc);                       <span class="comment">//param被推导为指向函数的指针，</span></span><br><span class="line">                                    <span class="comment">//类型是void(*)(int, double)</span></span><br><span class="line"><span class="built_in">f2</span>(someFunc);                       <span class="comment">//param被推导为指向函数的引用，</span></span><br><span class="line">                                    <span class="comment">//类型是void(&amp;)(int, double)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><ul>
<li>在模板类型推导期间, 作为引用的参数被视为非引用, 即它们的引用性会被忽略。</li>
<li>在推导通用引用参数的类型时, 左值参数得到特殊处理。</li>
<li>在推导按值传递参数的类型时, <strong>const</strong>和<strong>volatile</strong>参数被视为<strong>非const</strong>和<strong>非volatile</strong>。</li>
<li>在模板类型推导期间, 数组或函数名的参数会衰退为指针, 除非它们被用于初始化引用。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Effective Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Modern C++ Item 2</title>
    <url>/2024/02/29/Effective%20Modern%20C++%20Item%202/</url>
    <content><![CDATA[<h1 id="Understand-auto-type-deduction"><a href="#Understand-auto-type-deduction" class="headerlink" title="Understand auto type deduction"></a><strong>Understand <code>auto</code> type deduction</strong></h1><p>除了一个例外，<strong>auto</strong>类型推导就是模版类型推导。</p>
<p>模板类型推导使用下面这个函数模板，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(ParmaType param)</span></span>;</span><br><span class="line"><span class="built_in">f</span>(expr);                        <span class="comment">//使用一些表达式调用f</span></span><br></pre></td></tr></table></figure>

<p>而当一个变量使用<code>auto</code>进行声明时，<code>auto</code>扮演了模板中<code>T</code>的角色，变量的类型说明符扮演了<code>ParamType</code>的角色。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> cx = x;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; rx = x;</span><br></pre></td></tr></table></figure>

<p>我们可以认为生成了一些模板并推断出 <strong>auto</strong> 关键字的类型, 如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;            <span class="comment">//概念化的模板用来推导x的类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_for_x</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func_for_x</span>(<span class="number">27</span>);                 <span class="comment">//概念化调用：</span></span><br><span class="line">                                <span class="comment">//param的推导类型是x的类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;            <span class="comment">//概念化的模板用来推导cx的类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_for_cx</span><span class="params">(<span class="type">const</span> T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func_for_cx</span>(x);                 <span class="comment">//概念化调用：</span></span><br><span class="line">                                <span class="comment">//param的推导类型是cx的类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;            <span class="comment">//概念化的模板用来推导rx的类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_for_rx</span><span class="params">(<span class="type">const</span> T &amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func_for_rx</span>(x);                 <span class="comment">//概念化调用：</span></span><br><span class="line">                                <span class="comment">//param的推导类型是rx的类型</span></span><br></pre></td></tr></table></figure>

<p>Item1描述的三个情景稍作修改就能适用于auto：</p>
<ul>
<li>情景一：类型说明符是一个指针或引用但不是通用引用</li>
<li>情景二：类型说明符一个通用引用</li>
<li>情景三：类型说明符既不是指针也不是引用</li>
</ul>
<p>上文中描述了情况一和情况三，现在描述情况二：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; uref1 = x;               <span class="comment">//x是int左值，</span></span><br><span class="line">                                <span class="comment">//所以uref1类型为int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; uref2 = cx;              <span class="comment">//cx是const int左值，</span></span><br><span class="line">                                <span class="comment">//所以uref2类型为const int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; uref3 = <span class="number">27</span>;              <span class="comment">//27是int右值，</span></span><br><span class="line">                                <span class="comment">//所以uref3类型为int&amp;&amp;</span></span><br></pre></td></tr></table></figure>

<p>数组和函数名退化为指针同样适用于<code>auto</code>类型推导，这里就不举例了。</p>
<p>但是, 这里有一个例外需要我们注意：当<strong>auto</strong>声明变量的初始值设定项括在花括号”<strong>{}</strong>“中时, 推导类型为 <strong>std::initializer_list</strong>. 如果不能推导出这样的类型, 代码将被拒绝编译。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x1 = <span class="number">27</span>;                   <span class="comment">//类型是int，值是27</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">x2</span><span class="params">(<span class="number">27</span>)</span></span>;                    <span class="comment">//同上</span></span><br><span class="line"><span class="keyword">auto</span> x3 = &#123; <span class="number">27</span> &#125;;               <span class="comment">//类型是std::initializer_list&lt;int&gt;，</span></span><br><span class="line">                                <span class="comment">//值是&#123; 27 &#125;</span></span><br><span class="line"><span class="keyword">auto</span> x4&#123; <span class="number">27</span> &#125;;                  <span class="comment">//同上</span></span><br><span class="line"><span class="keyword">auto</span> x5 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3.0</span> &#125;;        <span class="comment">//错误！无法推导std::initializer_list&lt;T&gt;中的T</span></span><br></pre></td></tr></table></figure>

<p>这里发生了两种类型推导。一种是由于<code>auto</code>的使用：使用花括号进行初始化的x5必须被推导为<code>std::initializer_list</code>。但是<code>std::initializer_list</code>是一个模板。<code>std::initializer_list&lt;T&gt;</code>会被某种类型<code>T</code>实例化，所以这意味着<code>T</code>也会被推导。 在这个例子中推导之所以失败，是因为在花括号中的值并不是同一种类型。</p>
<p>因此<code>auto</code>类型推导和模板类型推导的真正区别在于，<code>auto</code>类型推导假定花括号表示<code>std::initializer_list</code>而模板类型不能推导花括号。</p>
<p>C++14允许<code>auto</code>用于函数返回值并会被推导，C++14的<em>lambda</em>函数也允许在形参声明中使用<code>auto</code>。但是在这些情况下<code>auto</code>使用<strong>模板类型推导</strong>的规则，而不是<code>auto</code>类型推导。因此, 具有返回花括号初始化器的<strong>auto</strong>返回类型的函数将无法编译:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">createInitList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;         <span class="comment">//错误！不能推导&#123; 1, 2, 3 &#125;的类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">auto</span> resetV = [&amp;v](<span class="type">const</span> <span class="keyword">auto</span>&amp; newValue)&#123; v = newValue; &#125;;        <span class="comment">//C++14</span></span><br><span class="line"><span class="built_in">resetV</span>(&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;);            <span class="comment">//错误！不能推导&#123; 1, 2, 3 &#125;的类型</span></span><br></pre></td></tr></table></figure>

<h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><ul>
<li><strong>auto</strong>类型推导通常与模板类型推导相同, 但<strong>auto</strong>类型推导假定花括号(“<strong>{}</strong>“)初始化表示 <strong>std::initializer_list</strong>,而模板类型推导则不然。</li>
<li>函数返回类型或 lambda 参数中的 <strong>auto</strong> 表示模板类型推导，而不是<strong>auto</strong>类型推导。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Effective Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Modern C++ Item 3</title>
    <url>/2024/03/02/Effective%20Modern%20C++%20Item%203/</url>
    <content><![CDATA[<h1 id="Understand-decltype"><a href="#Understand-decltype" class="headerlink" title="Understand decltype"></a><strong>Understand decltype</strong></h1><p>给定名称或表达式, <code>decltype</code>就会告诉你这个名字或者表达式的类型。<code>decltype</code>只是简单的返回名字或者表达式的类型，很正常。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">0</span>;                <span class="comment">//decltype(i)是const int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span></span>;        <span class="comment">//decltype(w)是const Widget&amp;</span></span><br><span class="line">                                <span class="comment">//decltype(f)是bool(const Widget&amp;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;                    <span class="comment">//decltype(Point::x)是int</span></span><br><span class="line">&#125;;                              <span class="comment">//decltype(Point::y)是int</span></span><br><span class="line"></span><br><span class="line">Widget w;                       <span class="comment">//decltype(w)是Widget</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">f</span>(w))…                      <span class="comment">//decltype(f(w))是bool</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;            <span class="comment">//std::vector的简化版本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> index);</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;                  <span class="comment">//decltype(v)是vector&lt;int&gt;</span></span><br><span class="line">…</span><br><span class="line"><span class="keyword">if</span> (v[<span class="number">0</span>] == <span class="number">0</span>)…                 <span class="comment">//decltype(v[0])是int&amp;</span></span><br></pre></td></tr></table></figure>



<p>在C++11中，<code>auto</code> 不能被用作函数模板的返回类型。因此<code>decltype</code>最主要的用途就是用于声明函数模板，而这个函数返回类型依赖于形参类型。</p>
<blockquote>
<p>[!NOTE]</p>
<p>在 C++14 中，<code>auto</code> 不能用作函数的返回类型，除非使用的是 C++14 中的泛型 lambda 表达式。此外，使用 <code>auto</code> 作为函数返回类型还有一些限制，主要涉及到函数模板和非静态成员函数的情况。</p>
<ol>
<li><p><strong>函数模板中的auto返回类型</strong>：在函数模板中，如果使用 <code>auto</code> 作为返回类型，编译器无法推导出实际类型，因为模板的参数类型可能在调用时才能确定。因此，在函数模板中使用 <code>auto</code> 作为返回类型是不合法的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不合法的例子</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">foo</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>非静态成员函数中的auto返回类型</strong>：C++ 中，非静态成员函数必须与类的实例相关联才能被调用。因此，在类定义时，非静态成员函数的声明只是描述了函数的接口，而不涉及任何特定实例的情况。返回类型的推导需要考虑类的实例。这些信息直到使用对象调用该函数时才会完全可见，因此在函数声明处无法推导出完整的返回类型，非静态成员函数不能使用 <code>auto</code> 作为返回类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不合法的例子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">myFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<p><strong>C++11</strong> 中的第一个版本是:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;    <span class="comment">//可以工作，</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">authAndAccess</span><span class="params">(Container&amp; c, Index i)</span>       <span class="comment">//但是需要改良</span></span></span><br><span class="line"><span class="function">    -&gt;<span class="title">decltype</span><span class="params">(c[i])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">authenticateUser</span>();</span><br><span class="line">    <span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数名称前面的<code>auto</code>不会做任何的类型推导工作。相反的，他使用了C++11的<strong>尾置返回类型</strong>语法，它允许使用入参作为返回类型推导的一部分。</p>
<p>C++11允许自动推导单一语句的<em>lambda</em>表达式的返回类型， C++14扩展到允许自动推导所有的<em>lambda</em>表达式和函数。因此在 <strong>C++14</strong> 中, 我们可以省略尾置返回类型而只使用 <strong>auto</strong>。先贡献一个<strong>错误</strong>版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;    <span class="comment">//C++14版本，</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">authAndAccess</span><span class="params">(Container&amp; c, Index i)</span>       <span class="comment">//不正确！！！</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">authenticateUser</span>();</span><br><span class="line">    <span class="keyword">return</span> c[i];                                <span class="comment">//从c[i]中推导返回类型</span></span><br><span class="line">&#125;</span><br><span class="line">std::deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line"><span class="built_in">authAndAccess</span>(d, <span class="number">5</span>) = <span class="number">10</span>;               <span class="comment">//认证用户，返回d[5]，然后把10赋值给它</span></span><br><span class="line">                                        <span class="comment">//无法通过编译器！</span></span><br></pre></td></tr></table></figure>

<p>在这里, <strong>d[5]</strong> 理应返回一个 <strong>int&amp;</strong>, 但是<strong>auto</strong>类型推导（此处实际是模板类型推导的那套规则）<strong>去除了了引用</strong>, 因此推导出了 <strong>int</strong> 的返回类型，是个<strong>右值</strong>。</p>
<p>所以我们需要使用<code>decltype</code>类型推导来推导它的返回值。<strong>decltype(auto)</strong> 的规则: <strong>auto</strong> 指定推导类型, 但推导时应该使用<strong>decltype</strong> 规则。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;    <span class="comment">//C++14版本，可以工作，但是还需要改良</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">authAndAccess</span><span class="params">(Container&amp; c, Index i)</span>            </span></span><br><span class="line"><span class="function"></span>&#123;                                               </span><br><span class="line">    <span class="built_in">authenticateUser</span>();</span><br><span class="line">    <span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>decltype(auto)</code>的使用不仅仅局限于函数返回类型，也可以对初始化表达式使用<code>decltype</code>推导的规则：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> Widget&amp; cw = w;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> myWidget1 = cw;                    <span class="comment">//auto类型推导</span></span><br><span class="line">                                        <span class="comment">//myWidget1的类型为Widget</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) myWidget2 = cw;          <span class="comment">//decltype类型推导</span></span><br><span class="line">                                        <span class="comment">//myWidget2的类型是const Widget&amp;</span></span><br></pre></td></tr></table></figure>



<p>目前容器是通过<strong>左值引入一个非const</strong>传递的, 如果也可以传递右值就好了。我们可以为右值容器定义一个重载版本, 但维护起来太麻烦了。这时我们需要<strong>通用引用</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;    <span class="comment">//最终的C++14版本</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">authAndAccess</span><span class="params">(Container&amp;&amp; c, Index i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">authenticateUser</span>();</span><br><span class="line">    <span class="keyword">return</span> std::forward&lt;Container&gt;(c)[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;    <span class="comment">//最终的C++11版本</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">authAndAccess</span><span class="params">(Container&amp;&amp; c, Index i)</span> -&gt;<span class="title">decltype</span><span class="params">(std::forward&lt;Container&gt;(c)[i])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">authenticateUser</span>();</span><br><span class="line">    <span class="keyword">return</span> std::forward&lt;Container&gt;(c)[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>decltype</code>有一些特殊情况：对于单纯的变量名，<code>decltype</code>只会返回变量的声明类型。然而，对于比单纯的变量名更复杂的左值表达式，<code>decltype</code>报告的类型始终是左值引用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">return</span> x;                            <span class="comment">//decltype(x）是int，所以f1返回int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (x);                          <span class="comment">//decltype((x))是int&amp;，所以f2返回int&amp;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><ul>
<li><strong>decltype</strong> 总是不加修改的产生变量或者表达式的类型。</li>
<li>对于名称以外的类型 <strong>T</strong> 的左值表达式, decltype 总是返回类型 <strong>T&amp;</strong>.</li>
<li>C++14 支持 <strong>decltype(auto)</strong>, 它与 <strong>auto</strong> 一样, 从其初始值设定项中推导类型, 但它使用 <strong>decltype</strong> 规则执行类型推导。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Effective Modern C++</tag>
      </tags>
  </entry>
</search>
