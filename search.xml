<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Effective Modern C++ Item 1</title>
    <url>/2024/02/28/Effective%20Modern%20C++%20Item%201/</url>
    <content><![CDATA[<h1 id="Understand-template-type-deduction"><a href="#Understand-template-type-deduction" class="headerlink" title="Understand template type deduction"></a>Understand template type deduction</h1><p><code>auto</code>是建立在模板类型推导的基础上的，这项条款能帮助理解<code>auto</code>基于的模板类型推导。</p>
<p>我们将基于这个模板进行讨论:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(expr);		<span class="comment">// call f with some expression</span></span><br></pre></td></tr></table></figure>
<p>在编译期间，编译器使用<code>expr</code>进行两个类型推导：一个是针对<code>T</code>的，另一个是针对<code>ParamType</code>的。这两个类型通常是不同的，因为<code>ParamType</code>包含一些修饰，比如<code>const</code>和引用修饰符。在这种情况下，<code>ParamType</code>是<code>const T&amp;</code>。</p>
<p><code>T</code>的类型推导不仅取决于<code>expr</code>的类型，也取决于<code>ParamType</code>的类型。这里有三种情况：</p>
<h3 id="第一种情况-ParamType是引用或者指针-但不是通用引用"><a href="#第一种情况-ParamType是引用或者指针-但不是通用引用" class="headerlink" title="第一种情况: ParamType是引用或者指针, 但不是通用引用"></a>第一种情况: <em>ParamType</em>是引用或者指针, 但不是通用引用</h3><p>规则是:</p>
<ul>
<li>如果 <strong><em>expr</em></strong> 的类型是引用, 则忽略引用部分.</li>
<li>然后将 <strong><em>expr</em></strong> 的类型与 <strong><em>ParamType</em></strong> 进行模式匹配以确定 <strong><em>T</em></strong>.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = x;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);                           <span class="comment">//T是int，param的类型是int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);                          <span class="comment">//T是const int，param的类型是const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx);                          <span class="comment">//T是const int，param的类型是const int&amp;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果我们将<code>f</code>的形参类型<code>T&amp;</code>改为<code>const T&amp;</code>，情况有所变化，<code>cx</code>和<code>rx</code>的<code>const</code>ness依然被遵守，但是因为假设<code>param</code>是reference-to-<code>const</code>，<code>const</code>不再被推导为<code>T</code>的一部分：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp; param)</span></span>;         <span class="comment">//param现在是reference-to-const</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;                     <span class="comment">//如之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;               <span class="comment">//如之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = x;              <span class="comment">//如之前一样</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);                           <span class="comment">//T是int，param的类型是const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);                          <span class="comment">//T是int，param的类型是const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx);                          <span class="comment">//T是int，param的类型是const int&amp;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果<code>param</code>是一个指针（或者指向<code>const</code>的指针）而不是引用，情况本质上也一样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T* param)</span></span>;               <span class="comment">//param现在是指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;                     <span class="comment">//同之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *px = &amp;x;             <span class="comment">//px是指向作为const int的x的指针</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(&amp;x);                          <span class="comment">//T是int，param的类型是int*</span></span><br><span class="line"><span class="built_in">f</span>(px);                          <span class="comment">//T是const int，param的类型是const int*</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="第二种情况-ParamType是通用引用"><a href="#第二种情况-ParamType是通用引用" class="headerlink" title="第二种情况: ParamType是通用引用"></a>第二种情况: <strong><em>ParamType</em></strong>是通用引用</h3><p>规则是:</p>
<ul>
<li>如果 <strong><em>expr</em></strong> 是左值，则 <strong>T</strong> 和 <strong>ParamType</strong> 都被推导为左值引用.</li>
<li>如果 <strong><em>expr</em></strong> 是右值，则适用第一种情况规则.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;              <span class="comment">//param现在是一个通用引用类型</span></span><br><span class="line">        </span><br><span class="line"><span class="type">int</span> x=<span class="number">27</span>;                       <span class="comment">//如之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx=x;                 <span class="comment">//如之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp; rx=cx;              <span class="comment">//如之前一样</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);                           <span class="comment">//x是左值，所以T是int&amp;，</span></span><br><span class="line">                                <span class="comment">//param类型也是int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(cx);                          <span class="comment">//cx是左值，所以T是const int&amp;，</span></span><br><span class="line">                                <span class="comment">//param类型也是const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(rx);                          <span class="comment">//rx是左值，所以T是const int&amp;，</span></span><br><span class="line">                                <span class="comment">//param类型也是const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">27</span>);                          <span class="comment">//27是右值，所以T是int，</span></span><br><span class="line">                                <span class="comment">//param类型就是int&amp;&amp;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>当通用引用被使用时，类型推导会区分左值实参和右值实参。</strong></p>
<h3 id="第三种情况-ParamType既不是指针也不是引用"><a href="#第三种情况-ParamType既不是指针也不是引用" class="headerlink" title="第三种情况: ParamType既不是指针也不是引用"></a>第三种情况: <strong><em>ParamType</em></strong>既不是指针也不是引用</h3><p>在这种情况下, 参数以<strong>传值（pass-by-value）</strong>的方式处理。无论传递什么，<code>param</code>都会成为它的一份拷贝——一个完整的新对象。</p>
<p>规则是：</p>
<ul>
<li>如果 <strong><em>expr\</em></strong> 的类型是引用, 则忽略引用部分。</li>
<li>在忽略 <strong><em>expr</em></strong> 的引用性之后, 也忽略任何 <strong>const</strong> 和 <strong>volatile</strong>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;		<span class="comment">// param is now pass-by-value(按值传递)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = x;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> ptr =  <span class="string">&quot;Fun with pointers&quot;</span>;       <span class="comment">//ptr是一个常量指针，指向常量对象 </span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">f</span>(x);                           <span class="comment">//T和param的类型都是int</span></span><br><span class="line"><span class="built_in">f</span>(cx);                          <span class="comment">//T和param的类型都是int</span></span><br><span class="line"><span class="built_in">f</span>(rx);                          <span class="comment">//T和param的类型都是int</span></span><br><span class="line"><span class="built_in">f</span>(ptr);                         <span class="comment">//传递const char * const类型的实参</span></span><br></pre></td></tr></table></figure>
<p>即使<code>cx</code>和<code>rx</code>表示<code>const</code>值，<code>param</code>也不是<code>const</code>。<code>param</code>是一个完全独立于<code>cx</code>和<code>rx</code>的对象。</p>
<h3 id="数组和函数参数的衰减"><a href="#数组和函数参数的衰减" class="headerlink" title="数组和函数参数的衰减"></a>数组和函数参数的衰减</h3><p>当我们将数组名称作为参数传递给函数时，它实际上会衰减为<strong>指向数组中第一个元素的指针。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;			<span class="comment">// pass-by-value</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> name[] = <span class="string">&quot;J. P. Briggs&quot;</span>;	<span class="comment">//name的类型是const char[13]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(name); 				<span class="comment">//name是一个数组，但是T被推导为const char*</span></span><br></pre></td></tr></table></figure>
<p>但是如果添加对数组的引用, 就可以推断出数组类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(name);				<span class="comment">//传数组给f</span></span><br></pre></td></tr></table></figure>
<p>不只是数组会退化为指针，函数类型也会退化为一个函数指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunc</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>)</span></span>;         <span class="comment">//someFunc是一个函数，</span></span><br><span class="line">                                    <span class="comment">//类型是void(int, double)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(T param)</span></span>;                   <span class="comment">//传值给f1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(T &amp; param)</span></span>;                 <span class="comment">//传引用给f2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f1</span>(someFunc);                       <span class="comment">//param被推导为指向函数的指针，</span></span><br><span class="line">                                    <span class="comment">//类型是void(*)(int, double)</span></span><br><span class="line"><span class="built_in">f2</span>(someFunc);                       <span class="comment">//param被推导为指向函数的引用，</span></span><br><span class="line">                                    <span class="comment">//类型是void(&amp;)(int, double)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><ul>
<li>在模板类型推导期间, 作为引用的参数被视为非引用, 即它们的引用性会被忽略。</li>
<li>在推导通用引用参数的类型时, 左值参数得到特殊处理。</li>
<li>在推导按值传递参数的类型时, <strong>const</strong>和<strong>volatile</strong>参数被视为<strong>非const</strong>和<strong>非volatile</strong>。</li>
<li>在模板类型推导期间, 数组或函数名的参数会衰退为指针, 除非它们被用于初始化引用。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Effective Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Modern C++ Item 2</title>
    <url>/2024/02/29/Effective%20Modern%20C++%20Item%202/</url>
    <content><![CDATA[<h1 id="Understand-auto-type-deduction"><a href="#Understand-auto-type-deduction" class="headerlink" title="Understand auto type deduction"></a><strong>Understand <code>auto</code> type deduction</strong></h1><p>除了一个例外，<strong>auto</strong>类型推导就是模版类型推导。</p>
<p>模板类型推导使用下面这个函数模板，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(ParmaType param)</span></span>;</span><br><span class="line"><span class="built_in">f</span>(expr);                        <span class="comment">//使用一些表达式调用f</span></span><br></pre></td></tr></table></figure>
<p>而当一个变量使用<code>auto</code>进行声明时，<code>auto</code>扮演了模板中<code>T</code>的角色，变量的类型说明符扮演了<code>ParamType</code>的角色。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> cx = x;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; rx = x;</span><br></pre></td></tr></table></figure>
<p>我们可以认为生成了一些模板并推断出 <strong>auto</strong> 关键字的类型, 如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;            <span class="comment">//概念化的模板用来推导x的类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_for_x</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func_for_x</span>(<span class="number">27</span>);                 <span class="comment">//概念化调用：</span></span><br><span class="line">                                <span class="comment">//param的推导类型是x的类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;            <span class="comment">//概念化的模板用来推导cx的类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_for_cx</span><span class="params">(<span class="type">const</span> T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func_for_cx</span>(x);                 <span class="comment">//概念化调用：</span></span><br><span class="line">                                <span class="comment">//param的推导类型是cx的类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;            <span class="comment">//概念化的模板用来推导rx的类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_for_rx</span><span class="params">(<span class="type">const</span> T &amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func_for_rx</span>(x);                 <span class="comment">//概念化调用：</span></span><br><span class="line">                                <span class="comment">//param的推导类型是rx的类型</span></span><br></pre></td></tr></table></figure>
<p>Item1描述的三个情景稍作修改就能适用于auto：</p>
<ul>
<li>情景一：类型说明符是一个指针或引用但不是通用引用</li>
<li>情景二：类型说明符一个通用引用</li>
<li>情景三：类型说明符既不是指针也不是引用</li>
</ul>
<p>上文中描述了情况一和情况三，现在描述情况二：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; uref1 = x;               <span class="comment">//x是int左值，</span></span><br><span class="line">                                <span class="comment">//所以uref1类型为int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; uref2 = cx;              <span class="comment">//cx是const int左值，</span></span><br><span class="line">                                <span class="comment">//所以uref2类型为const int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; uref3 = <span class="number">27</span>;              <span class="comment">//27是int右值，</span></span><br><span class="line">                                <span class="comment">//所以uref3类型为int&amp;&amp;</span></span><br></pre></td></tr></table></figure>
<p>数组和函数名退化为指针同样适用于<code>auto</code>类型推导，这里就不举例了。</p>
<p>但是, 这里有一个例外需要我们注意：当<strong>auto</strong>声明变量的初始值设定项括在花括号”<strong>{}</strong>“中时, 推导类型为 <strong>std::initializer_list</strong>. 如果不能推导出这样的类型, 代码将被拒绝编译。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x1 = <span class="number">27</span>;                   <span class="comment">//类型是int，值是27</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">x2</span><span class="params">(<span class="number">27</span>)</span></span>;                    <span class="comment">//同上</span></span><br><span class="line"><span class="keyword">auto</span> x3 = &#123; <span class="number">27</span> &#125;;               <span class="comment">//类型是std::initializer_list&lt;int&gt;，</span></span><br><span class="line">                                <span class="comment">//值是&#123; 27 &#125;</span></span><br><span class="line"><span class="keyword">auto</span> x4&#123; <span class="number">27</span> &#125;;                  <span class="comment">//同上</span></span><br><span class="line"><span class="keyword">auto</span> x5 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3.0</span> &#125;;        <span class="comment">//错误！无法推导std::initializer_list&lt;T&gt;中的T</span></span><br></pre></td></tr></table></figure>
<p>这里发生了两种类型推导。一种是由于<code>auto</code>的使用：使用花括号进行初始化的x5必须被推导为<code>std::initializer_list</code>。但是<code>std::initializer_list</code>是一个模板。<code>std::initializer_list&lt;T&gt;</code>会被某种类型<code>T</code>实例化，所以这意味着<code>T</code>也会被推导。 在这个例子中推导之所以失败，是因为在花括号中的值并不是同一种类型。</p>
<p>因此<code>auto</code>类型推导和模板类型推导的真正区别在于，<code>auto</code>类型推导假定花括号表示<code>std::initializer_list</code>而模板类型不能推导花括号。</p>
<p>C++14允许<code>auto</code>用于函数返回值并会被推导，C++14的<em>lambda</em>函数也允许在形参声明中使用<code>auto</code>。但是在这些情况下<code>auto</code>使用<strong>模板类型推导</strong>的规则，而不是<code>auto</code>类型推导。因此, 具有返回花括号初始化器的<strong>auto</strong>返回类型的函数将无法编译:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">createInitList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;         <span class="comment">//错误！不能推导&#123; 1, 2, 3 &#125;的类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">auto</span> resetV = [&amp;v](<span class="type">const</span> <span class="keyword">auto</span>&amp; newValue)&#123; v = newValue; &#125;;        <span class="comment">//C++14</span></span><br><span class="line"><span class="built_in">resetV</span>(&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;);            <span class="comment">//错误！不能推导&#123; 1, 2, 3 &#125;的类型</span></span><br></pre></td></tr></table></figure>
<h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><ul>
<li><strong>auto</strong>类型推导通常与模板类型推导相同, 但<strong>auto</strong>类型推导假定花括号(“<strong>{}</strong>“)初始化表示 <strong>std::initializer_list</strong>,而模板类型推导则不然。</li>
<li>函数返回类型或 lambda 参数中的 <strong>auto</strong> 表示模板类型推导，而不是<strong>auto</strong>类型推导。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Effective Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Modern C++ Item 3</title>
    <url>/2024/03/02/Effective%20Modern%20C++%20Item%203/</url>
    <content><![CDATA[<h1 id="Understand-decltype"><a href="#Understand-decltype" class="headerlink" title="Understand decltype"></a><strong>Understand decltype</strong></h1><p>给定名称或表达式, <code>decltype</code>就会告诉你这个名字或者表达式的类型。<code>decltype</code>只是简单的返回名字或者表达式的类型，很正常。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">0</span>;                <span class="comment">//decltype(i)是const int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span></span>;        <span class="comment">//decltype(w)是const Widget&amp;</span></span><br><span class="line">                                <span class="comment">//decltype(f)是bool(const Widget&amp;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;                    <span class="comment">//decltype(Point::x)是int</span></span><br><span class="line">&#125;;                              <span class="comment">//decltype(Point::y)是int</span></span><br><span class="line"></span><br><span class="line">Widget w;                       <span class="comment">//decltype(w)是Widget</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">f</span>(w))…                      <span class="comment">//decltype(f(w))是bool</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;            <span class="comment">//std::vector的简化版本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> index);</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;                  <span class="comment">//decltype(v)是vector&lt;int&gt;</span></span><br><span class="line">…</span><br><span class="line"><span class="keyword">if</span> (v[<span class="number">0</span>] == <span class="number">0</span>)…                 <span class="comment">//decltype(v[0])是int&amp;</span></span><br></pre></td></tr></table></figure>
<p>在C++11中，<code>auto</code> 不能被用作函数模板的返回类型。因此<code>decltype</code>最主要的用途就是用于声明函数模板，而这个函数返回类型依赖于形参类型。</p>
<blockquote>
<p>[!NOTE]</p>
<p>在 C++14 中，<code>auto</code> 不能用作函数的返回类型，除非使用的是 C++14 中的泛型 lambda 表达式。此外，使用 <code>auto</code> 作为函数返回类型还有一些限制，主要涉及到函数模板和非静态成员函数的情况。</p>
<ol>
<li><p><strong>函数模板中的auto返回类型</strong>：在函数模板中，如果使用 <code>auto</code> 作为返回类型，编译器无法推导出实际类型，因为模板的参数类型可能在调用时才能确定。因此，在函数模板中使用 <code>auto</code> 作为返回类型是不合法的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不合法的例子</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">foo</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>非静态成员函数中的auto返回类型</strong>：C++ 中，非静态成员函数必须与类的实例相关联才能被调用。因此，在类定义时，非静态成员函数的声明只是描述了函数的接口，而不涉及任何特定实例的情况。返回类型的推导需要考虑类的实例。这些信息直到使用对象调用该函数时才会完全可见，因此在函数声明处无法推导出完整的返回类型，非静态成员函数不能使用 <code>auto</code> 作为返回类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不合法的例子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">myFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p><strong>C++11</strong> 中的第一个版本是:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;    <span class="comment">//可以工作，</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">authAndAccess</span><span class="params">(Container&amp; c, Index i)</span>       <span class="comment">//但是需要改良</span></span></span><br><span class="line"><span class="function">    -&gt;<span class="title">decltype</span><span class="params">(c[i])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">authenticateUser</span>();</span><br><span class="line">    <span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数名称前面的<code>auto</code>不会做任何的类型推导工作。相反的，他使用了C++11的<strong>尾置返回类型</strong>语法，它允许使用入参作为返回类型推导的一部分。</p>
<p>C++11允许自动推导单一语句的<em>lambda</em>表达式的返回类型， C++14扩展到允许自动推导所有的<em>lambda</em>表达式和函数。因此在 <strong>C++14</strong> 中, 我们可以省略尾置返回类型而只使用 <strong>auto</strong>。先贡献一个<strong>错误</strong>版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;    <span class="comment">//C++14版本，</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">authAndAccess</span><span class="params">(Container&amp; c, Index i)</span>       <span class="comment">//不正确！！！</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">authenticateUser</span>();</span><br><span class="line">    <span class="keyword">return</span> c[i];                                <span class="comment">//从c[i]中推导返回类型</span></span><br><span class="line">&#125;</span><br><span class="line">std::deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line"><span class="built_in">authAndAccess</span>(d, <span class="number">5</span>) = <span class="number">10</span>;               <span class="comment">//认证用户，返回d[5]，然后把10赋值给它</span></span><br><span class="line">                                        <span class="comment">//无法通过编译器！</span></span><br></pre></td></tr></table></figure>
<p>在这里, <strong>d[5]</strong> 理应返回一个 <strong>int&amp;</strong>, 但是<strong>auto</strong>类型推导（此处实际是模板类型推导的那套规则）<strong>去除了了引用</strong>, 因此推导出了 <strong>int</strong> 的返回类型，是个<strong>右值</strong>。</p>
<p>所以我们需要使用<code>decltype</code>类型推导来推导它的返回值。<strong>decltype(auto)</strong> 的规则: <strong>auto</strong> 指定推导类型, 但推导时应该使用<strong>decltype</strong> 规则。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;    <span class="comment">//C++14版本，可以工作，但是还需要改良</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">authAndAccess</span><span class="params">(Container&amp; c, Index i)</span>            </span></span><br><span class="line"><span class="function"></span>&#123;                                               </span><br><span class="line">    <span class="built_in">authenticateUser</span>();</span><br><span class="line">    <span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>decltype(auto)</code>的使用不仅仅局限于函数返回类型，也可以对初始化表达式使用<code>decltype</code>推导的规则：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> Widget&amp; cw = w;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> myWidget1 = cw;                    <span class="comment">//auto类型推导</span></span><br><span class="line">                                        <span class="comment">//myWidget1的类型为Widget</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) myWidget2 = cw;          <span class="comment">//decltype类型推导</span></span><br><span class="line">                                        <span class="comment">//myWidget2的类型是const Widget&amp;</span></span><br></pre></td></tr></table></figure>
<p>目前容器是通过<strong>左值引入一个非const</strong>传递的, 如果也可以传递右值就好了。我们可以为右值容器定义一个重载版本, 但维护起来太麻烦了。这时我们需要<strong>通用引用</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;    <span class="comment">//最终的C++14版本</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">authAndAccess</span><span class="params">(Container&amp;&amp; c, Index i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">authenticateUser</span>();</span><br><span class="line">    <span class="keyword">return</span> std::forward&lt;Container&gt;(c)[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;    <span class="comment">//最终的C++11版本</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">authAndAccess</span><span class="params">(Container&amp;&amp; c, Index i)</span> -&gt;<span class="title">decltype</span><span class="params">(std::forward&lt;Container&gt;(c)[i])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">authenticateUser</span>();</span><br><span class="line">    <span class="keyword">return</span> std::forward&lt;Container&gt;(c)[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>decltype</code>有一些特殊情况：对于单纯的变量名，<code>decltype</code>只会返回变量的声明类型。然而，对于比单纯的变量名更复杂的左值表达式，<code>decltype</code>报告的类型始终是左值引用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">return</span> x;                            <span class="comment">//decltype(x）是int，所以f1返回int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (x);                          <span class="comment">//decltype((x))是int&amp;，所以f2返回int&amp;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><ul>
<li><strong>decltype</strong> 总是不加修改的产生变量或者表达式的类型。</li>
<li>对于名称以外的类型 <strong>T</strong> 的左值表达式, decltype 总是返回类型 <strong>T&amp;</strong>.</li>
<li>C++14 支持 <strong>decltype(auto)</strong>, 它与 <strong>auto</strong> 一样, 从其初始值设定项中推导类型, 但它使用 <strong>decltype</strong> 规则执行类型推导。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Effective Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Modern C++ Item 4</title>
    <url>/2024/03/02/Effective%20Modern%20C++%20Item%204/</url>
    <content><![CDATA[<h1 id="Know-how-to-view-deduced-types"><a href="#Know-how-to-view-deduced-types" class="headerlink" title="Know how to view deduced types"></a><strong>Know how to view deduced types</strong></h1><p>在 C++ 程序中, 有很多方法可以查看类型推导的结果：编辑代码的时候，在编译期间，在运行时。</p>
<h3 id="IDE-编译器"><a href="#IDE-编译器" class="headerlink" title="IDE 编译器"></a><strong>IDE 编译器</strong></h3><p>在IDE中的代码编辑器通常可以显示程序代码中变量，函数，参数的类型。为此，代码必须处于可编译状态，因为IDE之所以能提供这些信息是因为一个C++编译器（或者至少是前端中的一个部分）运行于IDE中。</p>
<h3 id="编译器诊断"><a href="#编译器诊断" class="headerlink" title="编译器诊断"></a><strong>编译器诊断</strong></h3><p>另一个获得推导结果的方法是使用编译器出错时提供的错误消息。</p>
<p>举个例子，可以声明一个类模板但<strong>不定义</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                <span class="comment">//只对TD进行声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TD</span>;                           <span class="comment">//TD == &quot;Type Displayer&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> theAnswer = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> x = theAnswer;</span><br><span class="line"><span class="keyword">auto</span> y = &amp;theAnswer;</span><br><span class="line"></span><br><span class="line">TD&lt;<span class="keyword">decltype</span>(x)&gt; xType;              <span class="comment">//引出包含x和y</span></span><br><span class="line">TD&lt;<span class="keyword">decltype</span>(y)&gt; yType;              <span class="comment">//的类型的错误消息</span></span><br></pre></td></tr></table></figure>
<p>如果尝试实例化这个类模板就会引出一个错误消息：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">error: <span class="string">&#x27;xType&#x27;</span> uses undefined <span class="keyword">class</span> <span class="string">&#x27;TD&lt;int&gt;&#x27;</span></span><br><span class="line">error: <span class="string">&#x27;yType&#x27;</span> uses undefined <span class="keyword">class</span> <span class="string">&#x27;TD&lt;const int *&gt;&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="运行时输出"><a href="#运行时输出" class="headerlink" title="运行时输出"></a><strong>运行时输出</strong></h3><p>在运行时显示类型的一个非常基本的用法是通过 <strong>typeid</strong> 和<strong>std::type_info::name</strong>这两个内置函数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="built_in">typeid</span>(x).<span class="built_in">name</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;  <span class="comment">//显示x和y的类型</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">typeid</span>(y).<span class="built_in">name</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>然而<strong>std::type_info::name</strong>并不总是正确，<code>std::type_info::name</code>规范批准像传值形参一样来对待这些类型。</p>
<p>Boost TypeIndex库（通常写作<strong>Boost.TypeIndex</strong>）是更好的选择：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::cout;</span><br><span class="line">    <span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示T</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T =     &quot;</span></span><br><span class="line">         &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;T&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">         &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//显示param类型</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;param = &quot;</span></span><br><span class="line">         &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(param)&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">         &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>boost::typeindex::type_id_with_cvr</code>获取一个类型实参（我们想获得相应信息的那个类型），它不消除实参的<code>const</code>，<code>volatile</code>和引用修饰符（因此模板名中有“<code>with_cvr</code>”）。</p>
<h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a><strong>重点</strong></h3><ul>
<li>使用 IDE 编辑器、编译器错误消息和 Boost TypeIndex 库经常可以方便地看到推导类型。</li>
<li>一些工具的结果可能既无帮助也不准确, 因此了解 <strong>C++</strong> 的类型推导规则仍然是必不可少的。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Effective Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>emplace_back Vs push_back</title>
    <url>/2023/09/23/emplace-back/</url>
    <content><![CDATA[<p><code>emplace_back()</code>是C++11的新特性</p>
<h2 id="emplace-back-和push-back-的区别"><a href="#emplace-back-和push-back-的区别" class="headerlink" title="emplace_back()和push_back()的区别"></a>emplace_back()和push_back()的区别</h2><ol>
<li><code>push_back()</code> 在vector尾部添加一个元素时，首先会创建一个临时对象，然后再将这个临时对象移动或拷贝到 vector 中<ul>
<li>如果是拷贝的话，事后会自动销毁先前创建的这个临时元素</li>
</ul>
</li>
<li><code>emplace_back()</code> 是直接在 vector 尾部创建这个元素，省去了移动或者拷贝元素的过程</li>
<li>但 <code>emplace_back()</code>并不是任何场景效率都比 <code>push_back()</code>高</li>
</ol>
<h2 id="emplace-back-效率更高的应用场景"><a href="#emplace-back-效率更高的应用场景" class="headerlink" title="emplace_back()效率更高的应用场景"></a>emplace_back()效率更高的应用场景</h2><p>在向 vector 中添加元素时（假设元素类型是一个类类型）</p>
<ol>
<li>如果添加的是类类型的有参构造函数的参数类型对应的变量：<ul>
<li>如果通过 <code>push_back()</code> 方式添加，则会调用<strong>一次有参构造 + 一次移动构造</strong> ，如果移动构造不可用则为拷贝构造</li>
<li>如果通过 <code>emplace_back()</code> 方式添加，则只会调用<strong>一次有参构造</strong></li>
</ul>
</li>
<li>如果添加的是类类型的变量：<ul>
<li>不论是通过 <code>push_back()</code> 方式还是 <code>emplace_back()</code> 方式，都只会调用<strong>一次拷贝构造</strong></li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span> (<span class="type">int</span> num) &#123;</span><br><span class="line">        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span> (<span class="type">const</span> Person &amp; p) &#123;</span><br><span class="line">        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;num = p.num;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;num=&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;num &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span> (Person &amp;&amp; p) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;num = p.num;</span><br><span class="line">        p.num = <span class="number">0</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;num=&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;num &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Person</span> () &#123;</span><br><span class="line">        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; __LINE__ &lt;&lt; endl;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">10</span>);  <span class="comment">// 会调用一次有参构造+一次移动构造</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; __LINE__ &lt;&lt; endl;</span><br><span class="line">    v.<span class="built_in">emplace_back</span>(<span class="number">20</span>);  <span class="comment">// 会调用一次有参构造</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; __LINE__ &lt;&lt; endl;</span><br><span class="line">    v.<span class="built_in">push_back</span>(p1);  <span class="comment">// 会调用一次拷贝构造</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; __LINE__ &lt;&lt; endl;</span><br><span class="line">    v.<span class="built_in">emplace_back</span>(p1);  <span class="comment">// 会调用一次拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以有参构造中的参数类型的变量作为实参来使用 <code>push_back()</code>和<code>emplace_back()</code> ，可以提升效率，但我认为这种实参形式不易于理解</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="http://c.biancheng.net/view/6826.html">http://c.biancheng.net/view/6826.html</a></p>
<p><a href="https://blog.csdn.net/unonoi/article/details/114680819?spm=1001.2101.3001.6650.5&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-114680819-blog-119282296.235%5Ev38%5Epc_relevant_anti_t3_base&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-114680819-blog-119282296.235%5Ev38%5Epc_relevant_anti_t3_base&amp;utm_relevant_index=9">https://blog.csdn.net/unonoi/article/details/114680819?spm=1001.2101.3001.6650.5&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-114680819-blog-119282296.235%5Ev38%5Epc_relevant_anti_t3_base&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-114680819-blog-119282296.235%5Ev38%5Epc_relevant_anti_t3_base&amp;utm_relevant_index=9</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>std::move</title>
    <url>/2023/09/15/std-move/</url>
    <content><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p><strong>左值</strong>：表达式结束后依然存在的持久对象(在<strong>内存</strong>中占有确定位置)</p>
<p><strong>右值</strong>：表达式结束时不再存在的临时对象(不在<strong>内存</strong>中占有确定位置）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> val; <span class="comment">// 对变量val进行了定义，故在栈上会给val分配内存地址</span></span><br><span class="line">val = <span class="number">4</span>; <span class="comment">// “=”要求左边是可修改的左值，4是临时参与运算的值，一般在寄存器上暂存</span></span><br></pre></td></tr></table></figure>
<h2 id="std-move函数"><a href="#std-move函数" class="headerlink" title="std::move函数"></a>std::move函数</h2><ul>
<li>将一个左值转换成右值引用，从而可以调用右值引用的拷贝构造函数</li>
<li>针对有在堆上为对象分配内存的情况</li>
<li>该函数仅仅做了<strong>类型转换(可理解为static_cast转换),</strong>对性能无影响。</li>
<li><strong>真正的移动操作</strong>在移动构造函数或者移动赋值操作符中发生，我们可以在自己的类中实现移动语义，避免深拷贝</li>
<li><strong>被move的值有没有失效，关键看有没有调用移动构造函数，或者移动复制运算符</strong><ul>
<li>单纯的<code>Foo &amp;&amp; f = std::move (x)</code>;  是不会调用移动构造或者移动赋值运算符的。 只是把右值给绑定到了<code>f</code>上。</li>
<li><code>Foo t = std::move (x)</code>, 这样才会调用移动构造函数</li>
</ul>
</li>
</ul>
<h2 id="Why-std-move"><a href="#Why-std-move" class="headerlink" title="Why std::move"></a>Why std::move</h2><p>右值引用和<code>std::move</code>广泛应用于在STL和自定义类中<strong>实现移动语义，避免拷贝，从而提升程序性能</strong></p>
<p>在没有右值引用之前，一个简单的数组类通常实现如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">int</span> size) : <span class="built_in">size_</span>(size) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">int</span>[size_];</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 深拷贝构造</span></span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">const</span> Array&amp; temp_array) &#123;</span><br><span class="line">        size_ = temp_array.size_;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="type">int</span>[size_];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size_; i ++) &#123;</span><br><span class="line">            data_[i] = temp_array.data_[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 深拷贝赋值,不可避免</span></span><br><span class="line">    Array&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Array&amp; temp_array) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line"> </span><br><span class="line">        size_ = temp_array.size_;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="type">int</span>[size_];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size_; i ++) &#123;</span><br><span class="line">            data_[i] = temp_array.data_[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~<span class="built_in">Array</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> *data_;</span><br><span class="line">    <span class="type">int</span> size_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>改进：提供一个<code>移动构造函数</code>，把被拷贝者的数据移动过来，之后丢弃被拷贝者，从而避免深拷贝</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">int</span> size) : <span class="built_in">size_</span>(size) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">int</span>[size_];</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 深拷贝构造</span></span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">const</span> Array&amp; temp_array) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 深拷贝赋值</span></span><br><span class="line">    Array&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Array&amp; temp_array) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 移动构造函数，可以浅拷贝</span></span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">const</span> Array&amp; temp_array, <span class="type">bool</span> move) &#123;</span><br><span class="line">        data_ = temp_array.data_;</span><br><span class="line">        size_ = temp_array.size_;</span><br><span class="line">        <span class="comment">// 为防止temp_array析构时delete data，提前置空其data_      </span></span><br><span class="line">        temp_array.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    ~<span class="built_in">Array</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] data_;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> *data_;</span><br><span class="line">    <span class="type">int</span> size_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样做有三个问题：</p>
<ol>
<li>不优雅，表示移动语义需要一个额外的参数</li>
<li><code>temp_array</code>是const左值引用，无法被修改为<code>nullptr</code></li>
<li>即使把函数参数改成非const <code>Array&amp; temp_array</code>，由于左值引用不能接右值，无法使用<code>Array a = Array(Array(), true);</code></li>
</ol>
<p>最终，使用右值引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Array a;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 左值a，用std::move转化为右值</span></span><br><span class="line">    <span class="function">Array <span class="title">b</span><span class="params">(std::move(a))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="std-move在STL容器中的应用"><a href="#std-move在STL容器中的应用" class="headerlink" title="std::move在STL容器中的应用"></a>std::move在STL容器中的应用</h2><p>在STL的很多容器中，都实现了以<strong>右值引用为参数</strong>的<strong>移动构造函数</strong>和<strong>移动赋值重载函数</strong>，或者其他函数</p>
<p>最常见的如std::vector的<code>push_back</code>和<code>emplace_back</code>。参数为左值引用意味着拷贝，为右值引用意味着移动。</p>
<p>有些STL类只有移动构造函数，比如<code>unique_ptr</code>，因此只能移动(转移内部对象所有权，或者叫浅拷贝)，不能深拷贝</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.cnblogs.com/shadow-lr/p/Introduce_Std-move.html">https://www.cnblogs.com/shadow-lr/p/Introduce_Std-move.html</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2024/02/26/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>并查集主要用来解决<strong>元素分组</strong>的问题。它支持两种操作：</p>
<ul>
<li><strong>合并（Union）</strong>：把两个不相交的集合合并成一个集合。</li>
<li><strong>查询（Find）</strong>：查询两个元素是否在同一个集合中。</li>
</ul>
<p>并查集的核心思想是<strong>用集合中的一个元素代表整个集合</strong>。</p>
<p><img src="https://raw.githubusercontent.com/lmqqqqqq/PicGo-Image/main/img/202402270258364.png" alt="image-20240227011735365" style="zoom: 50%;" /></p>
<p>并查集是一个<strong>树状</strong>的结构，要寻找集合中的代表元素，只需要向上一层一层访问父节点。</p>
<p>通过以上知识，可以先写出最简单版本的并查集代码。</p>
<p><strong>初始化</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fa[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span> <span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        fa[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用数组fa来存储每个元素的父节点。</p>
<p><strong>查询</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==x)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用递归一层一层访问父节点，直到根节点。<strong>通过判断两个元素的根节点是否一致，得出他们是否属于同一集合。</strong></p>
<p><strong>合并</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fa[<span class="built_in">find</span>(i)]=<span class="built_in">find</span>(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h2><p>最简单的并查集效率是比较低的。merge（2，4）会使得树变成一条长链。随着链的增长，从底部找到跟节点将越来越慢。</p>
<p><img src="https://raw.githubusercontent.com/lmqqqqqq/PicGo-Image/main/img/202402270258866.png" alt="image-20240227015949913" style="zoom:50%;" /></p>
<p>最好能够使得每个元素到根节点的距离尽可能短，距离只有1。</p>
<p><img src="https://raw.githubusercontent.com/lmqqqqqq/PicGo-Image/main/img/202402270258319.png" alt="image-20240227020533562" style="zoom:50%;" /></p>
<p>为了实现路径压缩，<strong>只需要在查询的过程中，把沿途的每个节点的父节点都设为根节点</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路径压缩</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==x)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        fa[x]=<span class="built_in">find</span>(fa[x]); <span class="comment">// 父节点设为根节点</span></span><br><span class="line">        <span class="keyword">return</span> fa[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="按秩合并"><a href="#按秩合并" class="headerlink" title="按秩合并"></a>按秩合并</h2><p>虽然经过了路径压缩这一优化，但并查集的结构仍然可能比较复杂。因为路径压缩只在查询时进行，而且只压缩一条路径。对于以下这种情况：</p>
<p><img src="https://raw.githubusercontent.com/lmqqqqqq/PicGo-Image/main/img/202402270259336.png" alt="image-20240227023419143" style="zoom:67%;" /></p>
<p>merge（7，8）有两种选择：把7的父节点设为8，或把8的父节点设为7。</p>
<p>显然后者好。要是把7的父节点设为8，会使树的深度增加1，每个节点寻找根节点的路径都会变长。虽然有路径压缩这一优化方案，但优化方案本身也是耗时的。如果把8的父节点设为7，就不会影响到原来的树结构。</p>
<p>所以，<strong>应该把简单的树往复杂的树上合并</strong>。</p>
<p>用一个数组depth记录每个根节点对应的树的深度。合并时比较两个根节点的depth，把depth小的往depth大的合并。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="built_in">find</span>(i), y=<span class="built_in">find</span>(j);</span><br><span class="line">    <span class="keyword">if</span>(depth[x]&lt;=depth[y])&#123;</span><br><span class="line">        fa[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        fa[y]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(depth[x]==depth[y] &amp;&amp; x!=y)&#123;</span><br><span class="line">        depth[y]++;  <span class="comment">//如果两个根节点深度相同，合并后的根节点深度+1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/93647900">https://zhuanlan.zhihu.com/p/93647900</a></p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>data structures</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Modern C++ Item 5</title>
    <url>/2024/03/04/Effective%20Modern%20C++%20Item%205/</url>
    <content><![CDATA[<h1 id="Prefer-auto-to-explicit-type-declarations"><a href="#Prefer-auto-to-explicit-type-declarations" class="headerlink" title="Prefer auto to explicit type declarations"></a><strong>Prefer <code>auto</code> to explicit type declarations</strong></h1><p>从 <strong>C++11</strong> 开始，<code>auto</code>变量从初始化表达式中推导出类型，这意味着我们必须显式地初始化一个变量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x1;                         <span class="comment">//潜在的未初始化的变量</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">auto</span> x2;                        <span class="comment">//错误！必须要初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> x3 = <span class="number">0</span>;                    <span class="comment">//没问题，x已经定义了</span></span><br></pre></td></tr></table></figure>
<p>而且省去了很多打代码的麻烦。考虑以下两段执行相同操作的代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> It&gt;           <span class="comment">//对从b到e的所有元素使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dwim</span><span class="params">(It b, It e)</span>           <span class="comment">//dwim（“do what I mean”）算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b != e) &#123;</span><br><span class="line">        <span class="keyword">typename</span> std::iterator_traits&lt;It&gt;::value_type currValue = *b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> It&gt;           <span class="comment">//如之前一样</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dwim</span><span class="params">(It b,It e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b != e) &#123;</span><br><span class="line">        <span class="keyword">auto</span> currValue = *b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Item2所述的<code>auto</code>类型推导技术，它甚至能表示一些只有编译器才知道的类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="keyword">auto</span> derefUPLess = </span><br><span class="line">    [](<span class="type">const</span> std::unique_ptr&lt;Widget&gt; &amp;p1,       <span class="comment">//用于std::unique_ptr</span></span><br><span class="line">       <span class="type">const</span> std::unique_ptr&lt;Widget&gt; &amp;p2)       <span class="comment">//指向的Widget类型的</span></span><br><span class="line">    &#123; <span class="keyword">return</span> *p1 &lt; *p2; &#125;;                      <span class="comment">//比较函数</span></span><br><span class="line"><span class="comment">// C++14</span></span><br><span class="line"><span class="keyword">auto</span> derefLess =                                </span><br><span class="line">    [](<span class="type">const</span> <span class="keyword">auto</span>&amp; p1,                          <span class="comment">//被任何像指针一样的东西</span></span><br><span class="line">       <span class="type">const</span> <span class="keyword">auto</span>&amp; p2)                          <span class="comment">//指向的值的比较函数</span></span><br><span class="line">    &#123; <span class="keyword">return</span> *p1 &lt; *p2; &#125;;</span><br></pre></td></tr></table></figure>
<p>但是，有人觉得不需要使用<code>auto</code>声明局部变量来保存一个闭包，可以使用<code>std::function</code>对象。</p>
<p><code>std::function</code>是一个C++11标准模板库中的一个模板，它泛化了函数指针的概念。<code>std::function</code>可以指向任何可调用对象。但创建<code>std::function</code>对象非常麻烦，而且还可能需要更多内存来存储闭包（堆上）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::function&lt;<span class="type">bool</span>(<span class="type">const</span> std::unique_ptr&lt;Widget&gt; &amp;,</span><br><span class="line">                   <span class="type">const</span> std::unique_ptr&lt;Widget&gt; &amp;)&gt;</span><br><span class="line">derefUPLess = [](<span class="type">const</span> std::unique_ptr&lt;Widget&gt; &amp;p1,</span><br><span class="line">                 <span class="type">const</span> std::unique_ptr&lt;Widget&gt; &amp;p2)</span><br><span class="line">                &#123; <span class="keyword">return</span> *p1 &lt; *p2; &#125;;</span><br></pre></td></tr></table></figure>
<p>使用<code>auto</code>除了可以避免未初始化的无效变量，省略冗长的声明类型，直接保存闭包外，还有一个好处是可以避免类型快捷方式有关的问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="type">unsigned</span> sz = v.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>
<p><code>v.size()</code>的标准返回类型是<code>std::vector&lt;int&gt;::size_type</code>。在<strong>Windows 32-bit</strong> <code>std::vector&lt;int&gt;::size_type</code>和<code>unsigned</code>是一样的大小，但是在<strong>Windows 64-bit</strong>上<code>std::vector&lt;int&gt;::size_type</code>是64位，<code>unsigned</code>是32位，这就会出问题。</p>
<p>还有一个例子，考虑以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::unordered_map&lt;std::string, <span class="type">int</span>&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> std::pair&lt;std::string, <span class="type">int</span>&gt;&amp; p : m)</span><br><span class="line">&#123;</span><br><span class="line">    …                                   <span class="comment">//用p做一些事</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>std::unordered_map</code>的<em>key</em>是<code>const</code>的，所以<code>std::pair</code>的类型是<code>std::pair&lt;const std::string, int&gt;</code>。由于类型不一致，编译器会通过拷贝<code>m</code>中的对象创建一个临时对象，然后把<code>p</code>的引用绑定到这个临时对象上。在每个循环迭代结束时，临时对象将会销毁。</p>
<p>使用<code>auto</code>可以避免这些很难被意识到的类型不匹配的错误：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; p : m)</span><br><span class="line">&#123;</span><br><span class="line">    …                                   <span class="comment">//如之前一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样不仅代码更简洁，而且确保与<strong>std::unordered_map</strong>中真实<strong>pair</strong>的引用“绑定”, 而并不只是一个临时拷贝的引用。</p>
<p><strong>重点</strong></p>
<ul>
<li><strong>auto</strong> 声明变量必须初始化, 通常它可以避免一些移植性和效率性的问题, 并可以简化重构, 且比明确指定类型的变量声明打更少的代码。</li>
<li><strong>auto</strong>声明变量会受到Item2和Item2中描述的陷阱的影响。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Effective Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Modern C++ Item 6</title>
    <url>/2024/03/05/Effective%20Modern%20C++%20Item%206/</url>
    <content><![CDATA[<h1 id="Use-the-explicitly-typed-initializer-idiom-when-auto-deduces-undesired-types"><a href="#Use-the-explicitly-typed-initializer-idiom-when-auto-deduces-undesired-types" class="headerlink" title="Use the explicitly typed initializer idiom when auto deduces undesired types"></a><strong>Use the explicitly typed initializer idiom when <code>auto</code> deduces undesired types</strong></h1><p>尽管 <strong>auto</strong> 相对于显式声明类型好处很多, 但还是有一些棘手的陷阱需要注意。</p>
<p>假如我有一个函数，参数为<code>Widget</code>，返回一个<code>std::vector&lt;bool&gt;</code>，这里的<code>bool</code>表示<code>Widget</code>是否提供一个独有的特性。我们可以写这样的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">features</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span></span>;</span><br><span class="line">Widget w;</span><br><span class="line"><span class="type">bool</span> highPriority = <span class="built_in">features</span>(w)[<span class="number">5</span>];     <span class="comment">//w高优先级吗？</span></span><br><span class="line"><span class="built_in">processWidget</span>(w, highPriority);         <span class="comment">//根据它的优先级处理w</span></span><br></pre></td></tr></table></figure>
<p>以上代码没有问题。但是使用<code>auto</code>代替<code>highPriority</code>的显式指定类型，就会出错：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> highPriority = <span class="built_in">features</span>(w)[<span class="number">5</span>];     <span class="comment">//w高优先级吗？</span></span><br><span class="line"><span class="built_in">processWidget</span>(w,highPriority);          <span class="comment">//未定义行为！</span></span><br></pre></td></tr></table></figure>
<p>为什么是一个未定义行为呢？<code>std::vector&lt;bool&gt;</code>以紧凑的形式存储它的<code>bool</code>，每个<code>bool</code>占一个bit。<code>std::vector&lt;T&gt;</code>的<code>operator[]</code>理应返回一个<code>T&amp;</code>，但是C++禁止对<code>bit</code>s的引用。因此，有一个返回的代理对象(<strong>proxy</strong>)来模仿 <strong>bool</strong> 的行为。<strong>std::vector</strong>中<strong>operator[]</strong>的返回类型其实是<strong>std::vector::reference</strong>。</p>
<p>在第一个版本中，<code>features</code>返回的<code>std::vector&lt;bool&gt;::reference</code>对象被隐式转换赋值给<code>bool</code>变量<code>highPriority</code>。</p>
<p>而在第二个版本中，<code>auto</code>推导<code>highPriority</code>的类型为<code>std::vector&lt;bool&gt;::reference</code>，包含一个指向这些<em>bit</em>s的指针。<code>highPriority</code>是这个<code>std::vector&lt;bool&gt;::reference</code>的拷贝，所以也包含一个指针。在这个语句结束的时候<code>std::vector&lt;bool&gt;::reference</code>将会被销毁，因此作为临时变量的<code>highPriority</code>包含一个悬置的指针，会造成未定义行为。</p>
<p>事实上, “代理(<strong>Proxy</strong>)”的设计模式是软件设计模式中历史最悠久的成员之一。一些代理类被设计于用以对客户可见。比如<code>std::shared_ptr</code>和<code>std::unique_ptr</code>。其他的代理类则或多或少不可见，比如<code>std::vector&lt;bool&gt;::reference</code>。</p>
<p>不可见代理类里一些C++库用了表达式模板的黑科技，能够提高数值运算的效率。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Matrix sum = m1 + m2 + m3 + m4;</span><br></pre></td></tr></table></figure>
<p>对两个<code>Matrix</code>对象使用<code>operator+</code>将会返回如<code>Sum&lt;Matrix, Matrix&gt;</code>这样的代理类而不是直接返回一个<code>Matrix</code>对象。上述表达式的结果可能是 <code>Sum&lt;Sum&lt;Sum&lt;Matrix, Matrix&gt;, Matrix&gt;, Matrix&gt;</code>, 如果需要具体求值时再一次性将其转换为 <strong>Matrix</strong> 对象，节省了计算次数。</p>
<p><strong>不可见的代理类通常不适用于<code>auto</code></strong>，这样类型的对象的生命期通常不能活过一条语句。 更好的解决方案是使用显式类型初始器惯用法：使用<code>auto</code>声明一个变量，然后对表达式强制类型转换（<em>cast</em>）得出期望的推导结果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> highPriority = <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(<span class="built_in">features</span>(w)[<span class="number">5</span>]);</span><br><span class="line"><span class="keyword">auto</span> sum = <span class="built_in">static_cast</span>&lt;Matrix&gt;(m1 + m2 + m3 + m4);</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calcEpsilon</span><span class="params">()</span></span>;                           </span><br><span class="line"><span class="keyword">auto</span> ep = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(<span class="built_in">calcEpsilon</span>());</span><br></pre></td></tr></table></figure>
<p><strong>重点</strong></p>
<ul>
<li>不可见的代理类(<strong>proxy</strong>)可能会导致 <strong>auto</strong> 从表达式推断出“错误”的类型。</li>
<li>显式类型初始器惯用法强制<code>auto</code>推导出你想要的结果。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Effective Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Modern C++ Item 14</title>
    <url>/2024/03/15/Effective%20Modern%20C++%20Item%2014/</url>
    <content><![CDATA[<h1 id="Declare-functions-noexcept-if-they-won’t-emit-exceptions"><a href="#Declare-functions-noexcept-if-they-won’t-emit-exceptions" class="headerlink" title="Declare functions noexcept if they won’t emit exceptions"></a><strong>Declare functions <code>noexcept</code> if they won’t emit exceptions</strong></h1><p>在C++98中，必须写出函数可能抛出的异常类型，如果函数实现有所改变，异常说明也可能需要修改。</p>
<p>从C++11开始，根据函数是否可能抛出异常或从不抛出异常的<strong>二分法</strong>来区分。<code>noexcept</code>保证函数不会抛出任何异常，同时允许编译器生成更好的目标代码。</p>
<p><code>noexcept</code>允许编译器生成更好的目标代码。考虑一个不会抛出异常的函数<code>f</code>，两种表达方式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span> <span class="title">throw</span><span class="params">()</span></span>;   <span class="comment">//C++98风格，没有来自f的异常</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span> <span class="keyword">noexcept</span></span>;  <span class="comment">//C++11风格，没有来自f的异常</span></span><br></pre></td></tr></table></figure>
<p>在<strong>C++98</strong>的异常说明中，调用栈会展开至<code>f</code>的调用者，随后程序被终止。在<strong>C++11</strong>异常说明中的，调用栈只有在程序执行终止之前才可能展开。因此，在一个<code>noexcept</code>函数中，优化器不需要保证运行时栈处于可展开状态；也不需要保证<code>noexcept</code>函数中的对象按照构造的反序析构。所以：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">RetType <span class="title">function</span><span class="params">(params)</span> <span class="keyword">noexcept</span></span>;  <span class="comment">//极尽所能优化</span></span><br><span class="line"><span class="function">RetType <span class="title">function</span><span class="params">(params)</span> <span class="title">throw</span><span class="params">()</span></span>;   <span class="comment">//较少优化</span></span><br><span class="line"><span class="function">RetType <span class="title">function</span><span class="params">(params)</span></span>;           <span class="comment">//较少优化</span></span><br></pre></td></tr></table></figure>
<p>其次, 对于某些功能, <strong>noexcept</strong>优化的机会更大。假如有一个<code>std::vector&lt;Widget&gt;</code>。<code>Widget</code>通过<code>push_back</code>一次又一次的添加进<code>std::vector</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;Widget&gt; vw;</span><br><span class="line">…</span><br><span class="line">Widget w;</span><br><span class="line">…                   <span class="comment">//用w做点事</span></span><br><span class="line">vw.<span class="built_in">push_back</span>(w);    <span class="comment">//把w添加进vw</span></span><br></pre></td></tr></table></figure>
<p>当<code>std::vector</code>的大小（size）等于它的容量（capacity），他会分配一个新的更大块的内存，并将元素从老内存区移动到新内存区，然后析构老内存区里的对象， 这就是 <code>std::vector</code>实现动态扩展的方式。这种方法使得<code>push_back</code>可以提供很强的异常安全保证：如果在复制元素期间抛出异常，<code>std::vector</code>状态保持不变。</p>
<p>在C++11中，移动语义的引入使得上述复制操作能够优化为移动操作，但这会破坏<code>push_back</code>的异常安全保证：异常在移动第n+1个元素时抛出，<code>push_back</code>操作没有完成。但是原始的<code>std::vector</code>已经被修改。</p>
<p>因此，<code>std::vector::push_back</code>通过检查移动操作是否被声明为<code>noexcept</code>。采用“如果可以就移动，如果必要则复制”策略。</p>
<p><code>swap</code>函数是<code>noexcept</code>的另一个绝佳用地。标准库的<code>swap</code>是否<code>noexcept</code>有时依赖于用户定义的<code>swap</code>是否<code>noexcept</code>。比如，数组和<code>std::pair</code>的<code>swap</code>声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T (&amp;a)[N],</span></span></span><br><span class="line"><span class="params"><span class="function">          T (&amp;b)[N])</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(swap(*a, *b)))</span></span>;  <span class="comment">//见下文</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span> &#123;</span><br><span class="line">    …</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(pair&amp; p)</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(swap(first, p.first)) &amp;&amp;</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">noexcept</span>(swap(second, p.second)))</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>高层次数据结构是否<code>noexcept</code>取决于它的构成部分的那些低层次数据结构是否<code>noexcept</code>。</p>
<p>大多数函数都是异常中立的，即缺少<code>noexcept</code>。这些函数自己不抛异常，但是它们内部的调用可能抛出。也就是说在当前这个函数内不处理异常，但是又不立即终止程序，而是让调用这个函数的函数处理异常。</p>
<p>默认情况下，内存释放函数和析构函数——不管是用户定义的还是编译器生成的——都是隐式<code>noexcept</code>。</p>
<p>一些库接口设计者会区分有宽泛契约（<strong>wild contracts</strong>）和严格契约（<strong>narrow contracts</strong>）的函数。有宽泛契约的函数没有前置条件。这种函数不管程序状态如何都能调用，它对调用者传来的实参不设约束。反之，没有宽泛契约的函数就有严格契约。对于这些函数，如果违反前置条件，结果将会是未定义的。</p>
<p>假如有一个形参为<code>std::string</code>的函数<code>f</code>，并且假定这个函数<code>f</code>决不引发异常。那么<code>f</code>应该被声明为<code>noexcept</code>。但是这个函数有一个前提条件: 传入的字符串长度不能超过<strong>32</strong>个字符。因此在窄契约中, <strong>noexcept</strong> 只是有条件的 <strong>noexcept</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> std::string&amp; s)</span> <span class="keyword">noexcept</span></span>;  <span class="comment">//前置条件：</span></span><br><span class="line">                                        <span class="comment">//s.length() &lt;= 32 </span></span><br></pre></td></tr></table></figure>
<p><strong>重点</strong></p>
<ul>
<li><strong>noexcept</strong>标记符是函数接口的一部分。</li>
<li><strong>noexcept</strong> 函数比<strong>non-noexcept</strong> 函数更容易优化。</li>
<li><strong>noexcept</strong> 对于移动语义, swap, 内存释放函数和析构函数特别有用。</li>
<li>大多数函数都是异常中立(可能抛也可能不抛异常)的, 而不是 <strong>noexcept</strong>。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Effective Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Modern C++ Item 18</title>
    <url>/2024/03/19/Effective%20Modern%20C++%20Item%2018/</url>
    <content><![CDATA[<h1 id="Item-18-Use-std-unique-ptr-for-exclusive-ownership-resource-management"><a href="#Item-18-Use-std-unique-ptr-for-exclusive-ownership-resource-management" class="headerlink" title="Item 18: Use std::unique_ptr for exclusive-ownership resource management"></a><strong>Item 18: Use <code>std::unique_ptr</code> for exclusive-ownership resource management</strong></h1><p><strong>std::unique_ptr</strong> 提供对象的独占所有权。不能复制 <strong>std::unique_ptr</strong>，只允许移动,，它将所有权从源指针转移到目标指针。</p>
<p><code>std::unique_ptr</code>的常见用法是作为工厂函数返回类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Investment</span> &#123; … &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stock</span>: <span class="keyword">public</span> Investment &#123; … &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bond</span>: <span class="keyword">public</span> Investment &#123; … &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealEstate</span>: <span class="keyword">public</span> Investment &#123; … &#125;;</span><br></pre></td></tr></table></figure>
<p><code>Investment</code>继承关系的工厂函数可以这样声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;            <span class="comment">//返回指向对象的std::unique_ptr，</span></span><br><span class="line">std::unique_ptr&lt;Investment&gt;         <span class="comment">//对象使用给定实参创建</span></span><br><span class="line"><span class="built_in">makeInvestment</span>(Ts&amp;&amp;... params);</span><br></pre></td></tr></table></figure>
<p>默认情况下，当 <strong>std::unique_ptr</strong> 超出生命周期范围时，销毁将通过<code>delete</code>进行，但是在构造过程中，<code>std::unique_ptr</code>对象可以被设置为使用<strong>自定义删除器</strong>。</p>
<p>假设想要在 <strong>Investment</strong> 对象被销毁之前打印日志，可以按如下方式实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> delInvmt = [](Investment* pInvestment)         <span class="comment">//自定义删除器</span></span><br><span class="line">                &#123;                                   <span class="comment">//（lambda表达式）</span></span><br><span class="line">                    <span class="built_in">makeLogEntry</span>(pInvestment);</span><br><span class="line">                    <span class="keyword">delete</span> pInvestment; </span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line">std::unique_ptr&lt;Investment, <span class="keyword">decltype</span>(delInvmt)&gt;     <span class="comment">//更改后的返回类型</span></span><br><span class="line"><span class="built_in">makeInvestment</span>(Ts&amp;&amp;... params)</span><br><span class="line">&#123;</span><br><span class="line">    std::unique_ptr&lt;Investment, <span class="keyword">decltype</span>(delInvmt)&gt; <span class="comment">//应返回的指针</span></span><br><span class="line">        <span class="built_in">pInv</span>(<span class="literal">nullptr</span>, delInvmt);</span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/*一个Stock对象应被创建*/</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pInv.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Stock</span>(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="comment">/*一个Bond对象应被创建*/</span> )   </span><br><span class="line">    &#123;     </span><br><span class="line">        ...</span><br><span class="line">    &#125;   </span><br><span class="line">    ... </span><br><span class="line">    <span class="keyword">return</span> pInv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个例子可以看出：</p>
<ul>
<li>所有的自定义的删除行为接受要销毁对象的原始指针，然后执行销毁操作。</li>
<li>使用自定义删除器时，删除器类型必须作为第二个类型实参传给<code>std::unique_ptr</code>。</li>
<li>为了将自定义删除器与智能指针关联，需要把自定义删除器作为构造函数的第二个实参。</li>
<li>不能将原始指针（比如<code>new</code>创建）赋值给<code>std::unique_ptr</code>，从原始指针到智能指针的隐式转换会出问题。</li>
<li>自定义删除器的一个形参，类型是基类类型，不管创建的对象的真实类型是基类还是子类，为此基类必须有虚析构函数。</li>
</ul>
<p>使用默认删除器时（如<code>delete</code>），<code>std::unique_ptr</code>对象和原始指针大小相同。当使用自定义删除器时，可能会增加<strong>std::unique_ptr</strong> 的大小。函数指针形式的删除器，会使<code>std::unique_ptr</code>的大小增加一个字。对于函数对象形式的删除器来说，变化的大小取决于函数对象中存储的状态多少，无状态函数对象（比如不捕获变量的<em>lambda</em>表达式）对大小没有影响，因此尽量使用<em>lambda</em>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> delInvmt1 = [](Investment* pInvestment)        <span class="comment">//无状态lambda的</span></span><br><span class="line">                 &#123;                                  <span class="comment">//自定义删除器</span></span><br><span class="line">                     <span class="built_in">makeLogEntry</span>(pInvestment);</span><br><span class="line">                     <span class="keyword">delete</span> pInvestment; </span><br><span class="line">                 &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;                            <span class="comment">//返回类型大小是</span></span><br><span class="line">std::unique_ptr&lt;Investment, <span class="keyword">decltype</span>(delInvmt1)&gt;    <span class="comment">//Investment*的大小</span></span><br><span class="line"><span class="built_in">makeInvestment</span>(Ts&amp;&amp;... args);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">delInvmt2</span><span class="params">(Investment* pInvestment)</span>             <span class="comment">//函数形式的</span></span></span><br><span class="line"><span class="function"></span>&#123;                                                   <span class="comment">//自定义删除器</span></span><br><span class="line">    <span class="built_in">makeLogEntry</span>(pInvestment);</span><br><span class="line">    <span class="keyword">delete</span> pInvestment;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;                            <span class="comment">//返回类型大小是</span></span><br><span class="line">std::unique_ptr&lt;Investment, <span class="built_in">void</span> (*)(Investment*)&gt;  <span class="comment">//Investment*的指针</span></span><br><span class="line"><span class="built_in">makeInvestment</span>(Ts&amp;&amp;... params);                     <span class="comment">//加至少一个函数指针的大小</span></span><br></pre></td></tr></table></figure>
<p><code>std::unique_ptr</code>有两种形式，一种用于单个对象（<code>std::unique_ptr&lt;T&gt;</code>），一种用于数组（<code>std::unique_ptr&lt;T[]&gt;</code>）。</p>
<p><code>std::unique_ptr</code>还可以轻松高效的转换为<code>std::shared_ptr</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;Investment&gt; sp =            <span class="comment">//将std::unique_ptr</span></span><br><span class="line">    <span class="built_in">makeInvestment</span>(arguments);              <span class="comment">//转为std::shared_ptr</span></span><br></pre></td></tr></table></figure>
<p><strong>重点</strong></p>
<ul>
<li><strong>std::unique_ptr</strong> 是一个轻量、快速、只能移动(<strong>move-only</strong>)的智能指针，用于管理具有独占所有权的资源。</li>
<li>默认情况下, 资源销毁通过<strong>delete</strong>实现，但可以指定自定义删除器。</li>
<li>有状态的自定义删除器和函数指针作为删除器会增加 <strong>std::unique_ptr</strong> 对象的大小。</li>
<li>将 <strong>std::unique_ptr</strong> 转换为 <strong>std::shared_ptr</strong> 很容易方便。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Effective Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Modern C++ Item 19</title>
    <url>/2024/03/20/Effective%20Modern%20C++%20Item%2019/</url>
    <content><![CDATA[<h1 id="Item-19-Use-std-shared-ptr-for-shared-ownership-resource-management"><a href="#Item-19-Use-std-shared-ptr-for-shared-ownership-resource-management" class="headerlink" title="Item 19: Use std::shared_ptr for shared-ownership resource management"></a><strong>Item 19: Use <code>std::shared_ptr</code> for shared-ownership resource management</strong></h1><p><strong>std::shared_ptr</strong> 是一个支持共享所有权对象资源管理的智能指针。它通过引用计数来确保是否是最后一个指向某种资源的指针，如果引用计数值为零，即不再指向对象时，最后一个 <strong>std::shared_ptr</strong>就会在析构函数中销毁资源。</p>
<p>引用计数有几个性能影响:</p>
<ul>
<li><strong><code>std::shared_ptr</code>大小是原始指针的两倍</strong>，因为它内部包含一个指向资源的原始指针，还包含一个指向资源的引用计数值的原始指针。</li>
<li><strong>引用计数的内存必须动态分配</strong>。 </li>
<li><strong>递增递减引用计数必须是原子性的</strong>。</li>
</ul>
<p><code>std::shared_ptr</code>和<code>std::unique_ptr</code>一样也支持自定义的删除器。但是，删除器类型不是<code>std::shared_ptr</code>的一部分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> loggingDel = [](Widget *pw)        <span class="comment">//自定义删除器</span></span><br><span class="line">                  &#123;                     <span class="comment">//（和条款18一样）</span></span><br><span class="line">                      <span class="built_in">makeLogEntry</span>(pw);</span><br><span class="line">                      <span class="keyword">delete</span> pw;</span><br><span class="line">                  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;                        <span class="comment">//删除器类型是</span></span></span><br><span class="line"><span class="function">    Widget, <span class="title">decltype</span><span class="params">(loggingDel)</span>        <span class="comment">//指针类型的一部分</span></span></span><br><span class="line"><span class="function">    &gt; <span class="title">upw</span><span class="params">(<span class="keyword">new</span> Widget, loggingDel)</span></span>;</span><br><span class="line">std::shared_ptr&lt;Widget&gt;                 <span class="comment">//删除器类型不是</span></span><br><span class="line">    <span class="built_in">spw</span>(<span class="keyword">new</span> Widget, loggingDel);        <span class="comment">//指针类型的一部分</span></span><br></pre></td></tr></table></figure>
<p>考虑有两个<code>std::shared_ptr&lt;Widget&gt;</code>，虽然带有不同的删除器，但他们是同一类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> customDeleter1 = [](Widget *pw) &#123; … &#125;;     <span class="comment">//自定义删除器，</span></span><br><span class="line"><span class="keyword">auto</span> customDeleter2 = [](Widget *pw) &#123; … &#125;;     <span class="comment">//每种类型不同</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">pw1</span><span class="params">(<span class="keyword">new</span> Widget, customDeleter1)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">pw2</span><span class="params">(<span class="keyword">new</span> Widget, customDeleter2)</span></span>;</span><br><span class="line">std::vector&lt;std::shared_ptr&lt;Widget&gt;&gt; vpw&#123; pw1, pw2 &#125;;</span><br></pre></td></tr></table></figure>
<p>此外，自定义删除器不会改变<code>std::shared_ptr</code>对象的大小。<code>std::shared_ptr</code>内部包含一个指向资源的原始指针，还包含一个指向<strong>控制块</strong>的指针。一个控制块包含引用计数、弱计数和指向自定义删除器、分配器等的额外功能指针。每个<code>std::shared_ptr</code>管理的对象都有个相应的控制块。</p>
<p><img src="https://raw.githubusercontent.com/lmqqqqqq/PicGo-Image/main/img/202403210005681.png" alt="image-20240321000449021" style="zoom:50%;" /></p>
<p>控制块的创建会遵循下面几条规则：</p>
<ul>
<li><code>std::make_shared</code>总是创建一个控制块。</li>
<li>当从独占指针（即<code>std::unique_ptr</code>或者<code>std::auto_ptr</code>）上构造出<code>std::shared_ptr</code>时会创建控制块。</li>
<li>当从原始指针上构造出<code>std::shared_ptr</code>时会创建控制块。</li>
</ul>
<p>关于第3点, 一般不建议从原始指针上构造一个<code>std::shared_ptr</code>，因为指向的对象容易有多个控制块关联，从而对象将会被销毁多次。如以下这个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> pw = <span class="keyword">new</span> Widget;                           <span class="comment">//pw是原始指针</span></span><br><span class="line">…</span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw1</span><span class="params">(pw, loggingDel)</span></span>;   <span class="comment">//为*pw创建控制块</span></span><br><span class="line">…</span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw2</span><span class="params">(pw, loggingDel)</span></span>;   <span class="comment">//为*pw创建第二个控制块</span></span><br></pre></td></tr></table></figure>
<p>因此，避免传给<code>std::shared_ptr</code>构造函数原始指针，而是使用<code>std::make_shared</code>。如果使用了自定义删除器导致无法使用<code>std::make_shared</code>，直接传<code>new</code>出来的结果，而不要传指针变量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw1</span><span class="params">(<span class="keyword">new</span> Widget,    <span class="comment">//直接使用new的结果</span></span></span></span><br><span class="line"><span class="params"><span class="function">                             loggingDel)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw2</span><span class="params">(spw1)</span></span>;         <span class="comment">//spw2使用spw1一样的控制块</span></span><br></pre></td></tr></table></figure>
<p>一个比较意外的地方是使用<code>this</code>指针作为<code>std::shared_ptr</code>构造函数实参可能创建多个控制块。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;std::shared_ptr&lt;Widget&gt;&gt; processedWidgets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::process</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …                                       <span class="comment">//处理Widget</span></span><br><span class="line">    processedWidgets.<span class="built_in">emplace_back</span>(<span class="keyword">this</span>);    <span class="comment">//然后将它加到已处理过的Widget</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>向<code>std::shared_ptr</code>的容器传递一个原始指针（<code>this</code>），根据控制块的创建规则3，<code>std::shared_ptr</code>会为指向的<code>Widget</code>（<code>*this</code>）创建一个控制块。但是成员函数外面早已存在指向那个<code>Widget</code>对象的指针。</p>
<p><code>std::shared_ptr</code>API有处理这种情况的模板类：<code>std::enable_shared_from_this&lt;T&gt;</code>和成员函数<code>shared_from_this（）</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>: <span class="keyword">public</span> std::enable_shared_from_this&lt;Widget&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::process</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//和之前一样，处理Widget</span></span><br><span class="line">    …</span><br><span class="line">    <span class="comment">//把指向当前对象的std::shared_ptr加入processedWidgets</span></span><br><span class="line">    processedWidgets.<span class="built_in">emplace_back</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>std::unique_ptr</code>可以转换为<code>std::shared_ptr</code>，但是<strong>反之不行</strong>。</p>
<p><code>std::shared_ptr</code>不支持数组的资源管理。到C++20才支持。</p>
<p><strong>重点</strong></p>
<ul>
<li><p><strong>std::shared_ptr</strong> 为有共享所有权的任意资源提供一种自动垃圾回收的便捷方式。</p>
</li>
<li><p>与 <strong>std::unique_ptr</strong> 相比, <strong>std::shared_ptr</strong> 对象通常大两倍, 会产生控制块的开销, 需要原子性的引用计数修改操作。</p>
</li>
<li><p>默认资源销毁是通过<strong>delete</strong>, 但支持自定义删除器. 删除器的类型对 <strong>std::shared_ptr</strong> 的声明类型没有影响。</p>
</li>
<li><p>避免从原始指针变量创建 <strong>std::shared_ptr</strong>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Effective Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Modern C++ Item 20</title>
    <url>/2024/03/21/Effective%20Modern%20C++%20Item%2020/</url>
    <content><![CDATA[<h1 id="Item-20-Use-std-weak-ptr-for-std-shared-ptr-like-pointers-that-can-dangle"><a href="#Item-20-Use-std-weak-ptr-for-std-shared-ptr-like-pointers-that-can-dangle" class="headerlink" title="Item 20: Use std::weak_ptr for std::shared_ptr-like pointers that can dangle"></a><strong>Item 20: Use <code>std::weak_ptr</code> for <code>std::shared_ptr</code>-like pointers that can dangle</strong></h1><p><code>std::weak_ptr</code>不是一个独立的智能指针。它是<code>std::shared_ptr</code>的增强。<code>std::weak_ptr</code>不能解引用，不会影响所指对象的引用计数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> spw =                      <span class="comment">//spw创建之后，指向的Widget的</span></span><br><span class="line">    std::<span class="built_in">make_shared</span>&lt;Widget&gt;(); <span class="comment">//引用计数（ref count，RC）为1。</span></span><br><span class="line">                                <span class="comment">//std::make_shared的信息参见条款21</span></span><br><span class="line">…</span><br><span class="line"><span class="function">std::weak_ptr&lt;Widget&gt; <span class="title">wpw</span><span class="params">(spw)</span></span>; <span class="comment">//wpw指向与spw所指相同的Widget。RC仍为1</span></span><br><span class="line">…</span><br><span class="line">spw = <span class="literal">nullptr</span>;                  <span class="comment">//RC变为0，Widget被销毁。</span></span><br><span class="line">                                <span class="comment">//wpw现在悬空</span></span><br></pre></td></tr></table></figure>
<p><code>std::weak_ptr</code>通常从<code>std::shared_ptr</code>上创建，并使用<code>expired()</code>检查它是否悬空。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (wpw.<span class="built_in">expired</span>()) …            <span class="comment">//如果wpw没有指向对象…</span></span><br></pre></td></tr></table></figure>
<p><code>std::weak_ptr</code>如果没有悬空，那我们肯定是想访问它的对象的。考虑到它没有解引用操作，我们可以通过从<code>std::weak_ptr</code>创建<code>std::shared_ptr</code>来实现访问所指对象：</p>
<ul>
<li>使用<code>std::weak_ptr::lock</code>，它返回一个<code>std::shared_ptr</code>，如果<code>std::weak_ptr</code>悬空，<code>std::shared_ptr</code>为空。</li>
<li>以<code>std::weak_ptr</code>为实参构造<code>std::shared_ptr</code>。如果<code>std::weak_ptr</code>悬空，会抛出一个异常。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;Widget&gt; spw1 = wpw.<span class="built_in">lock</span>();  <span class="comment">//如果wpw过期，spw1就为空</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw3</span><span class="params">(wpw)</span></span>;          <span class="comment">//如果wpw过期，抛出std::bad_weak_ptr异常</span></span><br></pre></td></tr></table></figure>
<p><strong>std::weak_ptr</strong> 有三种主要用法:</p>
<ol>
<li><p><strong>缓存</strong></p>
<p>我们希望将一些计算结果存储在缓存中, 缓存对象的指针需要知道它是否已经悬空。所以缓存应该使用<code>std::weak_ptr</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">const</span> Widget&gt; <span class="title">fastLoadWidget</span><span class="params">(WidgetID id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> std::unordered_map&lt;WidgetID,</span><br><span class="line">                              std::weak_ptr&lt;<span class="type">const</span> Widget&gt;&gt; cache;</span><br><span class="line">                                        <span class="comment">//译者注：这里std::weak_ptr&lt;const Widget&gt;是高亮</span></span><br><span class="line">    <span class="keyword">auto</span> objPtr = cache[id].<span class="built_in">lock</span>();     <span class="comment">//objPtr是去缓存对象的</span></span><br><span class="line">                                        <span class="comment">//std::shared_ptr（或</span></span><br><span class="line">                                        <span class="comment">//当对象不在缓存中时为null）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!objPtr) &#123;                      <span class="comment">//如果不在缓存中</span></span><br><span class="line">        objPtr = <span class="built_in">loadWidget</span>(id);        <span class="comment">//加载它</span></span><br><span class="line">        cache[id] = objPtr;             <span class="comment">//缓存它</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>观察者设计模式</strong></p>
<p>观察者设计模式有<strong>observers</strong>观察的<strong>subjects</strong>。每个<strong>subjects</strong>都持有指向其<strong>observers</strong>的指针。因此如果<strong>subjects</strong>状态发生变化, 它可以向<strong>observers</strong>发送更新。但它必须确保如果<strong>observers</strong>被销毁后不再访问它。<strong>std::weak_ptr</strong> 是此处使用的正确指针类型。</p>
</li>
<li><p><strong>循环引用</strong></p>
<p>有一个用例, <strong>A</strong> 持有 <strong>B</strong> 的一个 <strong>std::shared_ptr</strong>，但 <strong>B</strong> 也想指向回 <strong>A</strong>.，如下图所示:</p>
<p><img src="https://cntransgroup.github.io/EffectiveModernCppChinese/4.SmartPointers/media/item20_fig2.png" alt="item20_fig2"></p>
<ul>
<li>使用原始指针：如果 A 被销毁, B 可能会无意中引用到悬挂指针，不好。</li>
<li><code>std::shared_ptr</code>：A和B都互相持有对方的<code>std::shared_ptr</code>，导致了循环引用，错误。</li>
<li><code>std::weak_ptr</code>：尽管A和B互相指向对方，B的指针不会影响A的引用计数，正确。</li>
</ul>
</li>
</ol>
<p>从效率角度来看，<code>std::weak_ptr</code>与<code>std::shared_ptr</code>基本相同。</p>
<p><strong>重点</strong></p>
<ul>
<li>将 <strong>std::weak_ptr</strong> 替代可能会悬空的 <strong>std::shared_ptr</strong> 。</li>
<li><strong>std::weak_ptr</strong> 的潜在使用场景包括缓存、观察者列表和打破 <strong>std::shared_ptr</strong> 循环结构。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Effective Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Modern C++ Item 21</title>
    <url>/2024/03/23/Effective%20Modern%20C++%20Item%2021/</url>
    <content><![CDATA[<h1 id="Prefer-std-make-unique-and-std-make-shared-to-direct-use-of-new"><a href="#Prefer-std-make-unique-and-std-make-shared-to-direct-use-of-new" class="headerlink" title="Prefer std::make_unique and std::make_shared to direct use of new"></a><strong>Prefer <code>std::make_unique</code> and <code>std::make_shared</code> to direct use of <code>new</code></strong></h1><p>一般情况下, 更倾向于使用<strong>make</strong>系列函数来创建智能指针，而不是直接使用<strong>new</strong>。</p>
<p>首先, 它避免了代码重复。使用<code>new</code>的版本重复了类型，但是<code>make</code>函数的版本没有。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">upw1</span><span class="params">(std::make_unique&lt;Widget&gt;())</span></span>;      <span class="comment">//使用make函数</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;Widget&gt; <span class="title">upw2</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;   <span class="comment">//不使用make函数</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">spw1</span><span class="params">(std::make_shared&lt;Widget&gt;())</span></span>;      <span class="comment">//使用make函数</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw2</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;   <span class="comment">//不使用make函数</span></span><br></pre></td></tr></table></figure>
<p>其次, <strong>make</strong> 系列函数有助于实现更好的异常安全代码。考虑以下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processWidget</span><span class="params">(std::shared_ptr&lt;Widget&gt; spw, <span class="type">int</span> priority)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">computePriority</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), <span class="built_in">computePriority</span>()); <span class="comment">//潜在的资源泄漏！   </span></span><br></pre></td></tr></table></figure>
<p>在运行时，必须执行以下操作，<code>processWidget</code>才开始执行：</p>
<ul>
<li>一个<code>Widget</code>对象必须在堆上被创建</li>
<li><code>std::shared_ptr&lt;Widget&gt;</code>构造函数执行</li>
<li>运行<code>computePriority（）</code></li>
</ul>
<p>以上三个操作可以按任意顺序执行。但如果正好按以顺序执行，<code>computePriority()</code> 抛出异常, 第一步动态分配的<code>Widget</code>就会泄漏。</p>
<p>使用<code>std::make_shared</code>可以防止这种问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">make_shared</span>&lt;Widget&gt;(),  <span class="built_in">computePriority</span>()); <span class="comment">//没有潜在的资源泄漏    </span></span><br></pre></td></tr></table></figure>
<p>第三，使用<code>std::make_shared</code>能提升效率。</p>
<p>直接使用<code>new</code>需要为<code>Widget</code>进行两次内存分配，一次为<code>Widget</code>对象，一次为控制块。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br></pre></td></tr></table></figure>
<p>使用<code>std::make_shared</code>只分配一块内存，同时容纳了<code>Widget</code>对象和控制块。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> spw = std::<span class="built_in">make_shared</span>&lt;Widget&gt;();</span><br></pre></td></tr></table></figure>
<p>但是有些情况下不适用<code>std::make_shared</code>。例如，<code>make</code>函数都不允许指定自定义删除器。如果想为智能指针指定一个自定义删除器, 只能直接使用 <strong>new</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> widgetDeleter = [](Widget* pw) &#123; … &#125;;</span><br><span class="line"><span class="function">std::unique_ptr&lt;Widget, <span class="title">decltype</span><span class="params">(widgetDeleter)</span>&gt; <span class="title">upw</span><span class="params">(<span class="keyword">new</span> Widget, widgetDeleter)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget, widgetDeleter)</span></span>;    </span><br></pre></td></tr></table></figure>
<p>第二，<code>make</code>函数中，完美转发使用小括号，而不是花括号。如果想用花括号初始化指向的对象，就必须使用<code>new</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a vector of 10 elements, each equal to 20</span></span><br><span class="line"><span class="keyword">auto</span> spv = std::make_shared&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//折中方案，创建std::initializer_list</span></span><br><span class="line"><span class="keyword">auto</span> initList = &#123; <span class="number">10</span>, <span class="number">20</span> &#125;;</span><br><span class="line"><span class="comment">//使用std::initializer_list为形参的构造函数创建std::vector</span></span><br><span class="line"><span class="keyword">auto</span> spv = std::make_shared&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(initList);</span><br></pre></td></tr></table></figure>
<p>对于<code>std::shared_ptr</code>和它的<code>make</code>函数，还有2个问题。</p>
<p>第一是一些重载了<code>operator new</code>和<code>operator delete</code>的类。他们不太适用于<code>std::shared_ptr</code>对自定义分配和释放的支持。</p>
<p>第二是分配的对象非常大并且有 <strong>std::weak_ptr</strong> 指向它。通过<code>std::shared_ptr</code>的<code>make</code>函数分配的内存（对象+控制快），直到最后一个<code>std::shared_ptr</code>和最后一个指向它的<code>std::weak_ptr</code>都下降到 <strong>count=0</strong> 时，才会释放控制快，从而释放内存。这不适用于系统内存很吃紧的情况。</p>
<p>如果处于不合适使用<code>std::make_shared</code>的情况下，最好的方法是确保在直接使用<code>new</code>时，在<strong>一个不做其他事情的语句中</strong>，立即将结果传递到智能指针构造函数。防止在使用<code>new</code>和调用管理<code>new</code>出来对象的智能指针的构造函数之间发生异常。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget, cusDel),  <span class="built_in">computePriority</span>());</span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget, cusDel)</span></span>;</span><br><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">move</span>(spw), <span class="built_in">computePriority</span>());   <span class="comment">//高效且异常安全</span></span><br></pre></td></tr></table></figure>
<p><strong>重点</strong></p>
<ul>
<li><p>相比于直接使用<strong>new</strong>, <strong>std::make_unique</strong>和<strong>std::make_shared</strong>可以消除代码重复, 提高异常安全性且生成的代码更小更快。</p>
</li>
<li><p>不适合使用<strong>std::make_X</strong>系列函数的情况包括需要指定自定义删除器和希望用花括号初始化。</p>
</li>
<li><p>对于 <strong>std::shared_ptr</strong>, 其他不建议使用<strong>make</strong> 系列函数的情况还包括 (1) 具有自定义内存管理的类 (2) 有内存担忧的系统(3) 非常大的对象、(4)比相应的 <strong>std::shared_ptr</strong> 生命周期更长的的 <strong>std::weak_ptr</strong>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Effective Modern C++</tag>
      </tags>
  </entry>
</search>
