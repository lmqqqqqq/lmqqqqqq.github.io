<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>std::move</title>
    <url>/2023/09/15/std-move/</url>
    <content><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p><strong>左值</strong>：表达式结束后依然存在的持久对象(在<strong>内存</strong>中占有确定位置)</p>
<p><strong>右值</strong>：表达式结束时不再存在的临时对象(不在<strong>内存</strong>中占有确定位置）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> val; <span class="comment">// 对变量val进行了定义，故在栈上会给val分配内存地址</span></span><br><span class="line">val = <span class="number">4</span>; <span class="comment">// “=”要求左边是可修改的左值，4是临时参与运算的值，一般在寄存器上暂存</span></span><br></pre></td></tr></table></figure>



<h2 id="std-move函数"><a href="#std-move函数" class="headerlink" title="std::move函数"></a>std::move函数</h2><ul>
<li>将一个左值转换成右值引用，从而可以调用右值引用的拷贝构造函数</li>
<li>针对有在堆上为对象分配内存的情况</li>
<li>该函数仅仅做了**类型转换(可理解为static_cast转换),**对性能无影响。</li>
<li><strong>真正的移动操作</strong>在移动构造函数或者移动赋值操作符中发生，我们可以在自己的类中实现移动语义，避免深拷贝</li>
<li><strong>被move的值有没有失效，关键看有没有调用移动构造函数，或者移动复制运算符</strong><ul>
<li>单纯的<code>Foo &amp;&amp; f = std::move (x)</code>;  是不会调用移动构造或者移动赋值运算符的。 只是把右值给绑定到了<code>f</code>上。</li>
<li><code>Foo t = std::move (x)</code>, 这样才会调用移动构造函数</li>
</ul>
</li>
</ul>
<h2 id="Why-std-move"><a href="#Why-std-move" class="headerlink" title="Why std::move"></a>Why std::move</h2><p>右值引用和<code>std::move</code>广泛应用于在STL和自定义类中<strong>实现移动语义，避免拷贝，从而提升程序性能</strong></p>
<p>在没有右值引用之前，一个简单的数组类通常实现如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">int</span> size) : <span class="built_in">size_</span>(size) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">int</span>[size_];</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 深拷贝构造</span></span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">const</span> Array&amp; temp_array) &#123;</span><br><span class="line">        size_ = temp_array.size_;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="type">int</span>[size_];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size_; i ++) &#123;</span><br><span class="line">            data_[i] = temp_array.data_[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 深拷贝赋值,不可避免</span></span><br><span class="line">    Array&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Array&amp; temp_array) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line"> </span><br><span class="line">        size_ = temp_array.size_;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="type">int</span>[size_];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size_; i ++) &#123;</span><br><span class="line">            data_[i] = temp_array.data_[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~<span class="built_in">Array</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> *data_;</span><br><span class="line">    <span class="type">int</span> size_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>改进：提供一个<code>移动构造函数</code>，把被拷贝者的数据移动过来，之后丢弃被拷贝者，从而避免深拷贝</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">int</span> size) : <span class="built_in">size_</span>(size) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">int</span>[size_];</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 深拷贝构造</span></span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">const</span> Array&amp; temp_array) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 深拷贝赋值</span></span><br><span class="line">    Array&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Array&amp; temp_array) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 移动构造函数，可以浅拷贝</span></span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">const</span> Array&amp; temp_array, <span class="type">bool</span> move) &#123;</span><br><span class="line">        data_ = temp_array.data_;</span><br><span class="line">        size_ = temp_array.size_;</span><br><span class="line">        <span class="comment">// 为防止temp_array析构时delete data，提前置空其data_      </span></span><br><span class="line">        temp_array.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    ~<span class="built_in">Array</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] data_;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> *data_;</span><br><span class="line">    <span class="type">int</span> size_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样做有三个问题：</p>
<ol>
<li>不优雅，表示移动语义需要一个额外的参数</li>
<li><code>temp_array</code>是const左值引用，无法被修改为<code>nullptr</code></li>
<li>即使把函数参数改成非const <code>Array&amp; temp_array</code>，由于左值引用不能接右值，无法使用<code>Array a = Array(Array(), true);</code></li>
</ol>
<p>最终，使用右值引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Array a;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 左值a，用std::move转化为右值</span></span><br><span class="line">    <span class="function">Array <span class="title">b</span><span class="params">(std::move(a))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="std-move在STL容器中的应用"><a href="#std-move在STL容器中的应用" class="headerlink" title="std::move在STL容器中的应用"></a>std::move在STL容器中的应用</h2><p>在STL的很多容器中，都实现了以<strong>右值引用为参数</strong>的<strong>移动构造函数</strong>和<strong>移动赋值重载函数</strong>，或者其他函数</p>
<p>最常见的如std::vector的<code>push_back</code>和<code>emplace_back</code>。参数为左值引用意味着拷贝，为右值引用意味着移动。</p>
<p>有些STL类只有移动构造函数，比如<code>unique_ptr</code>，因此只能移动(转移内部对象所有权，或者叫浅拷贝)，不能深拷贝</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.cnblogs.com/shadow-lr/p/Introduce_Std-move.html">https://www.cnblogs.com/shadow-lr/p/Introduce_Std-move.html</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>emplace_back Vs push_back</title>
    <url>/2023/09/23/emplace-back/</url>
    <content><![CDATA[<p><code>emplace_back()</code>是C++11的新特性</p>
<h2 id="emplace-back-和push-back-的区别"><a href="#emplace-back-和push-back-的区别" class="headerlink" title="emplace_back()和push_back()的区别"></a>emplace_back()和push_back()的区别</h2><ol>
<li><code>push_back()</code> 在vector尾部添加一个元素时，首先会创建一个临时对象，然后再将这个临时对象移动或拷贝到 vector 中<ul>
<li>如果是拷贝的话，事后会自动销毁先前创建的这个临时元素</li>
</ul>
</li>
<li><code>emplace_back()</code> 是直接在 vector 尾部创建这个元素，省去了移动或者拷贝元素的过程</li>
<li>但 <code>emplace_back()</code>并不是任何场景效率都比 <code>push_back()</code>高</li>
</ol>
<h2 id="emplace-back-效率更高的应用场景"><a href="#emplace-back-效率更高的应用场景" class="headerlink" title="emplace_back()效率更高的应用场景"></a>emplace_back()效率更高的应用场景</h2><p>在向 vector 中添加元素时（假设元素类型是一个类类型）</p>
<ol>
<li>如果添加的是类类型的有参构造函数的参数类型对应的变量：<ul>
<li>如果通过 <code>push_back()</code> 方式添加，则会调用<strong>一次有参构造 + 一次移动构造</strong> ，如果移动构造不可用则为拷贝构造</li>
<li>如果通过 <code>emplace_back()</code> 方式添加，则只会调用<strong>一次有参构造</strong></li>
</ul>
</li>
<li>如果添加的是类类型的变量：<ul>
<li>不论是通过 <code>push_back()</code> 方式还是 <code>emplace_back()</code> 方式，都只会调用<strong>一次拷贝构造</strong></li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span> (<span class="type">int</span> num) &#123;</span><br><span class="line">        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span> (<span class="type">const</span> Person &amp; p) &#123;</span><br><span class="line">        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;num = p.num;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;num=&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;num &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span> (Person &amp;&amp; p) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;num = p.num;</span><br><span class="line">        p.num = <span class="number">0</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;num=&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;num &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Person</span> () &#123;</span><br><span class="line">        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; __LINE__ &lt;&lt; endl;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">10</span>);  <span class="comment">// 会调用一次有参构造+一次移动构造</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; __LINE__ &lt;&lt; endl;</span><br><span class="line">    v.<span class="built_in">emplace_back</span>(<span class="number">20</span>);  <span class="comment">// 会调用一次有参构造</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; __LINE__ &lt;&lt; endl;</span><br><span class="line">    v.<span class="built_in">push_back</span>(p1);  <span class="comment">// 会调用一次拷贝构造</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; __LINE__ &lt;&lt; endl;</span><br><span class="line">    v.<span class="built_in">emplace_back</span>(p1);  <span class="comment">// 会调用一次拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以有参构造中的参数类型的变量作为实参来使用 <code>push_back()</code>和<code>emplace_back()</code> ，可以提升效率，但我认为这种实参形式不易于理解</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="http://c.biancheng.net/view/6826.html">http://c.biancheng.net/view/6826.html</a></p>
<p><a href="https://blog.csdn.net/unonoi/article/details/114680819?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5-114680819-blog-119282296.235%5Ev38%5Epc_relevant_anti_t3_base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5-114680819-blog-119282296.235%5Ev38%5Epc_relevant_anti_t3_base&utm_relevant_index=9">https://blog.csdn.net/unonoi/article/details/114680819?spm=1001.2101.3001.6650.5&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-114680819-blog-119282296.235%5Ev38%5Epc_relevant_anti_t3_base&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-114680819-blog-119282296.235%5Ev38%5Epc_relevant_anti_t3_base&amp;utm_relevant_index=9</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer 24 反转链表</title>
    <url>/2023/08/14/offer24/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1>]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>605种花问题</title>
    <url>/2024/02/08/605%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p>
<p>给你一个整数数组 <code>flowerbed</code> 表示花坛，由若干 <code>0</code> 和 <code>1</code> 组成，其中 <code>0</code> 表示没种植花，<code>1</code> 表示种植了花。另有一个数 <code>n</code> ，能否在不打破种植规则的情况下种入 <code>n</code> 朵花？能则返回 <code>true</code> ，不能则返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：flowerbed = [1,0,0,0,1], n = 1</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：flowerbed = [1,0,0,0,1], n = 2</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>



<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先使用贪心策略，在不打破规则的情况下种植尽可能多的花，然后判断可以种入的花的最大数量是否≥n。</p>
<p>可以种花的条件是<strong>数组中出现连续的三个0</strong>。</p>
<p>此题的边界情况需要额外注意，若可种植的位置<code>flowerbed[i]</code>在数组的开头或末尾，通过忽略<code>flowerbed[i-1]</code>或<code>flowerbed[i+1]</code>进行条件的判断是比较方便的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPlaceFlowers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; flowerbed, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len=flowerbed.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((i==<span class="number">0</span> || flowerbed[i<span class="number">-1</span>]==<span class="number">0</span>) &amp;&amp; flowerbed[i]==<span class="number">0</span> &amp;&amp;(i+<span class="number">1</span>==len || flowerbed[i+<span class="number">1</span>]==<span class="number">0</span>))&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                flowerbed[i]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans&gt;=n;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>334递增的三元子序列</title>
    <url>/2024/02/08/334%E9%80%92%E5%A2%9E%E7%9A%84%E4%B8%89%E5%85%83%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个整数数组 <code>nums</code> ，判断这个数组中是否存在长度为 <code>3</code> 的递增子序列。</p>
<p>如果存在这样的三元组下标 <code>(i, j, k)</code> 且满足 <code>i &lt; j &lt; k</code> ，使得 <code>nums[i] &lt; nums[j] &lt; nums[k]</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,4,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：任何 i &lt; j &lt; k 的三元组都满足题意</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,4,3,2,1]</span><br><span class="line">输出：false</span><br><span class="line">解释：不存在满足题意的三元组</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,1,5,0,4,6]</span><br><span class="line">输出：true</span><br><span class="line">解释：三元组 (3, 4, 5) 满足题意，因为 nums[3] == 0 &lt; nums[4] == 4 &lt; nums[5] == 6</span><br></pre></td></tr></table></figure>



<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="方法一：双向遍历"><a href="#方法一：双向遍历" class="headerlink" title="方法一：双向遍历"></a>方法一：双向遍历</h2><p>存在三元组下标 <code>(i, j, k)</code> 等价于<code>nums[j]</code>左边的最小值小于<code>nums[j]</code>，<code>nums[j]</code>右边的最大值大于<code>nums[j]</code>。</p>
<p>因此，可以维护数组中每个元素左边的最小值和右边的最大值。</p>
<p>创建两个长度为<code>n</code>的数组<code>leftmin</code>和<code>rightmax</code>，通过一次正向遍历计算<code>leftmin</code>，一次反向遍历计算<code>rightmax</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">increasingTriplet</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">3</span>)&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftmin</span><span class="params">(n,<span class="number">0</span>)</span>, <span class="title">rightmax</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        leftmin[<span class="number">0</span>]=nums[<span class="number">0</span>];     </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            leftmin[i]=<span class="built_in">min</span>(nums[i],leftmin[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        rightmax[n<span class="number">-1</span>]=nums[n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            rightmax[i]=<span class="built_in">max</span>(nums[i], rightmax[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(leftmin[i<span class="number">-1</span>]&lt;nums[i]&amp;&amp;nums[i]&lt;rightmax[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="方法二：贪心"><a href="#方法二：贪心" class="headerlink" title="方法二：贪心"></a>方法二：贪心</h2><p>贪心策略：在遍历数组的过程中，维护两个变量<code>first</code>和 <code>second</code>，使得<code>first&lt;second</code>恒成立，并使<code>first</code>和 <code>second</code>尽可能小。</p>
<p>在寻找第三个元素<code>num</code>时，如果</p>
<ol>
<li><code>num&gt;second</code>, 那么三元子序列找到了。</li>
<li><code>first&lt;num&lt;=second</code>，那么将<code>second</code>更新为<code>num</code>。在当前位置未找到<code>third</code>的情况下，将<code>second</code>变得更小将更有利于找到<code>third</code>。</li>
<li><code>num&lt;=first</code>，那么将<code>first</code>更新为<code>num</code>。虽然此时<code>first</code>在<code>second</code>的后面，但并不妨碍。在更新前，已经存在<code>first‘&lt;second</code>，此时能否成功找到<code>third</code>，只与<code>second</code>有关，和更新完的<code>first</code>并没有关系。</li>
</ol>
<p>**使用贪心可以将空间复杂度优化为：O(1)**。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">increasingTriplet</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> first = nums[<span class="number">0</span>], second = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;second)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]&gt;first &amp;&amp; nums[i]&lt;=second)&#123;</span><br><span class="line">                second=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                first=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>283移动零</title>
    <url>/2024/02/09/283%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [0]</span><br><span class="line">输出: [0]</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>11盛最多水的容器</title>
    <url>/2024/02/09/11%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p>
<p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49 </span><br><span class="line">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：height = [1,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>



<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>设两指针 <code>i</code> , <code>j</code> ，指向的高度分别为 <code>h[i]</code>, <code>h[j]</code> 。此题的难点在于如何移动双指针，不会丢失面积最大值。</p>
<p>在每个状态下，无论长板或短板向中间移动一格，都会导致水槽底边宽度变短：</p>
<ul>
<li>若向内移动短板，水槽的短板可能变大，因此下个水槽的面积可能增大 。</li>
<li>若向内移动长板，水槽的短板不变或变小，因此下个水槽的面积一定变小 。</li>
</ul>
<p>因此每次都是移动短板。</p>
<p>可以证明，在短板向内移动的过程中，一定不会丢失面积最大值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>, right=height.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> ans=(right-left) * <span class="built_in">min</span>(height[left], height[right]);</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[left]&lt;height[right])&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans, (right-left) * <span class="built_in">min</span>(height[left], height[right]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>1679K和数对的最大数目</title>
    <url>/2024/02/10/1679K%E5%92%8C%E6%95%B0%E5%AF%B9%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p>
<p>每一步操作中，你需要从数组中选出和为 <code>k</code> 的两个整数，并将它们移出数组。</p>
<p>返回你可以对数组执行的最大操作数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,4], k = 5</span><br><span class="line">输出：2</span><br><span class="line">解释：开始时 nums = [1,2,3,4]：</span><br><span class="line">- 移出 1 和 4 ，之后 nums = [2,3]</span><br><span class="line">- 移出 2 和 3 ，之后 nums = []</span><br><span class="line">不再有和为 5 的数对，因此最多执行 2 次操作。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,1,3,4,3], k = 6</span><br><span class="line">输出：1</span><br><span class="line">解释：开始时 nums = [3,1,3,4,3]：</span><br><span class="line">- 移出前两个 3 ，之后nums = [1,4,3]</span><br><span class="line">不再有和为 6 的数对，因此最多执行 1 次操作。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^9</code></li>
<li><code>1 &lt;= k &lt;= 10^9</code></li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h2><ol>
<li><p>先将数据排序，用两个指针分别指向数组的头尾。</p>
</li>
<li><p>再将两个指针指向的数求和。</p>
<ul>
<li>若和大于<code>k</code>，右指针左移，使和变小。</li>
<li>若和小于<code>k</code>，左指针右移，使和变大。</li>
<li>若和等于<code>k</code>，则两个指针都往中间移动，<code>ans</code>+1。</li>
</ul>
</li>
<li><p>循环步骤2直至左指针大于右指针。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>, right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left]+nums[right]==k)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[left]+nums[right]&lt;k)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="方法二：哈希表"><a href="#方法二：哈希表" class="headerlink" title="方法二：哈希表"></a>方法二：哈希表</h2><p>使用哈希表统计每个整数出现的次数，(x,k−x) 这两个数最多可以被移出 <em>min</em>⁡( count(x), count(k-x) )次。</p>
<p><strong>当2x&#x3D;k时，需要特殊判断</strong>。</p>
<p>需要注意的是：</p>
<ul>
<li>访问一个未在<code>unordered_map</code>或 <code>map</code> 中存在的键，那么会自动创建该键，并将value初始化为默认值。</li>
<li>在<code>map</code>中，插入、删除和查找操作的时间复杂度是 <em>O</em>(log<em>n</em>)，在<code>unordered_map</code>中，是 <em>O</em>(1)。</li>
<li><code>count()</code> 和 <code>find()</code> 成员函数都是用于检查某个键是否存在的方法，<code>count()</code> 返回的是键的出现次数（0 或 1），<code>find()</code> 返回的是指向键值对的迭代器。</li>
<li>此题k的数量级为10^9, 因此不能遍历1-k的所有整数，而应该遍历哈希表中的所有键值对。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums) &#123;</span><br><span class="line">            m[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [key,value]:m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(key*<span class="number">2</span>==k)&#123;</span><br><span class="line">                ans+=value/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(key*<span class="number">2</span>&lt;k &amp;&amp; m.<span class="built_in">count</span>(k-key))&#123;</span><br><span class="line">                ans+=<span class="built_in">min</span>(value,m[k-key]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
</search>
